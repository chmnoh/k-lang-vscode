# [PackageDev] target_format: plist, ext: tmLanguage
---
name: K
scopeName: source.k
fileTypes: [k]
uuid: 11be6ccf-19c5-4c1d-8d4e-9b33a14c78f7

patterns:
- include: '#preprocessor'
- include: '#comment'
- include: '#directives'
- include: '#declarations'
- include: '#script-top-level'

repository:
  directives:
    patterns:
    - include: '#extern-alias-directive'
    - include: '#using-directive'
    - include: '#import-directive'
    - include: '#attribute-section'
    - include: '#punctuation-semicolon'

  declarations:
    patterns:
    - include: '#namespace-declaration'
    - include: '#type-declarations'
    - include: '#punctuation-semicolon'

  script-top-level:
    patterns:
    - include: '#method-declaration'
    - include: '#statement'
    - include: '#punctuation-semicolon'

  type-declarations:
    patterns:
    - include: '#preprocessor'
    - include: '#comment'
    - include: '#storage-modifier'
    - include: '#class-declaration'
    - include: '#delegate-declaration'
    - include: '#enum-declaration'
    - include: '#interface-declaration'
    - include: '#record-declaration'
    - include: '#struct-declaration'
    - include: '#attribute-section'
    - include: '#punctuation-semicolon'

  class-or-struct-members:
    patterns:
    - include: '#preprocessor'
    - include: '#comment'
    - include: '#storage-modifier'
    - include: '#type-declarations'
    - include: '#property-declaration'
    - include: '#field-declaration'
    - include: '#event-declaration'
    - include: '#indexer-declaration'
    - include: '#variable-initializer'
    - include: '#constructor-declaration'
    - include: '#destructor-declaration'
    - include: '#operator-declaration'
    - include: '#conversion-operator-declaration'
    - include: '#method-declaration'
    - include: '#attribute-section'
    - include: '#punctuation-semicolon'

  interface-members:
    patterns:
    - include: '#preprocessor'
    - include: '#comment'
    - include: '#property-declaration'
    - include: '#event-declaration'
    - include: '#indexer-declaration'
    - include: '#method-declaration'
    - include: '#attribute-section'
    - include: '#punctuation-semicolon'

  statement:
    patterns:
    - include: '#preprocessor'
    - include: '#comment'
    - include: '#kql-statement'
    - include: '#while-statement'
    - include: '#do-statement'
    - include: '#for-in-statement'
    - include: '#for-to-statement'
    - include: '#for-statement'
    - include: '#foreach-statement'
    - include: '#if-statement'
    - include: '#else-part'
    - include: '#switch-statement'
    - include: '#goto-statement'
    - include: '#return-statement'
    - include: '#break-or-continue-statement'
    - include: '#throw-statement'
    - include: '#yield-statement'
    - include: '#await-statement'
    - include: '#try-statement'
    - include: '#checked-unchecked-statement'
    - include: '#lock-statement'
    - include: '#using-statement'
    - include: '#labeled-statement'
    - include: '#object-creation-expression'
    - include: '#array-creation-expression'
    - include: '#anonymous-object-creation-expression'
    - include: '#local-declaration'
    - include: '#block'
    - include: '#expression'
    - include: '#punctuation-semicolon'

  expression:
    patterns:
    - include: '#preprocessor'
    - include: '#comment'
    - include: '#checked-unchecked-expression'
    - include: '#typeof-or-default-expression'
    - include: '#nameof-expression'
    - include: '#throw-expression'
    - include: '#interpolated-string'
    - include: '#verbatim-interpolated-string'
    - include: '#this-or-base-expression'
    - include: '#switch-expression'
    - include: '#conditional-operator'
    - include: '#expression-operators'
    - include: '#await-expression'
    - include: '#query-expression'
    - include: '#as-expression'
    - include: '#is-expression'
    - include: '#anonymous-method-expression'
    - include: '#object-creation-expression'
    - include: '#array-creation-expression'
    - include: '#anonymous-object-creation-expression'
    - include: '#invocation-expression'
    - include: '#member-access-expression'
    - include: '#element-access-expression'
    - include: '#cast-expression'
    - include: '#literal'
    - include: '#parenthesized-expression'
    - include: '#tuple-deconstruction-assignment'
    - include: '#initializer-expression'
    - include: '#identifier'

  extern-alias-directive:
    begin: \s*(extern)\b\s*(alias)\b\s*(@?[_[:alpha:]][_[:alnum:]]*)
    beginCaptures:
      '1': { name: keyword.other.extern.k }
      '2': { name: keyword.other.alias.k }
      '3': { name: variable.other.alias.k }
    end: (?=;)

  using-directive:
    patterns:
    - begin: \b(using)\b\s+(static)\s+
      beginCaptures:
        '1': { name: keyword.other.using.k }
        '2': { name: keyword.other.static.k }
      end: (?=;)
      patterns:
      - include: '#type'
    - begin: \b(using)\s+(?=(@?[_[:alpha:]][_[:alnum:]]*)\s*=)
      beginCaptures:
        '1': { name: keyword.other.using.k }
        '2': { name: entity.name.type.alias.k }
      end: (?=;)
      patterns:
      - include: '#comment'
      - include: '#type'
      - include: '#operator-assignment'
    - begin: \b(using)\s*
      beginCaptures:
        '1': { name: keyword.other.using.k }
      end: (?=;)
      patterns:
      - include: '#comment'
      - name: entity.name.type.namespace.k
        match: '@?[_[:alpha:]][_[:alnum:]]*'
      - include: '#operator-assignment'

  import-directive:
    patterns:
    - begin: ^(import)\s+(?=(?<identifier>([_[:alpha:]][_[:alnum:]]*))\s*)
      beginCaptures:
        '1': { name: keyword.other.using.k }
        '2': { name: keyword.other.namespace.k }
      end: (?=\n)
      patterns:
      - include: '#comment'
      - include: '#punctuation-comma'
      - match: |-
          (?x)
          ([_[:alpha:]][_[:alnum:]]*)\b\s*
          (?=,)
        captures:
          '1': {name: keyword.other.namespace.k }

  attribute-section:
    begin: (\[)(assembly|module|field|event|method|param|property|return|type)?(\:)?
    beginCaptures:
      '1': { name: punctuation.squarebracket.open.k }
      '2': { name: keyword.other.attribute-specifier.k }
      '3': { name: punctuation.separator.colon.k }
    end: (\])
    endCaptures:
      '1': { name: punctuation.squarebracket.close.k }
    patterns:
    - include: '#comment'
    - include: '#attribute'
    - include: '#punctuation-comma'

  attribute:
    patterns:
    - include: '#type-name'
    - include: '#attribute-arguments'

  attribute-arguments:
    begin: (\()
    beginCaptures:
      '1': { name: punctuation.parenthesis.open.k }
    end: (\))
    endCaptures:
      '1': { name: punctuation.parenthesis.close.k }
    patterns:
    - include: '#attribute-named-argument'
    - include: '#expression'
    - include: '#punctuation-comma'

  attribute-named-argument:
    begin: (@?[_[:alpha:]][_[:alnum:]]*)\s*(?==)
    beginCaptures:
      '1': { name: entity.name.variable.property.k }
    end: (?=(,|\)))
    patterns:
    - include: '#operator-assignment'
    - include: '#expression'

  namespace-declaration:
    begin: \b(namespace)\s+
    beginCaptures:
      '1': { name: keyword.other.namespace.k }
    end: (?<=\})
    patterns:
    - include: '#comment'
    - name: entity.name.type.namespace.k
      match: '@?[_[:alpha:]][_[:alnum:]]*'
    - include: '#punctuation-accessor'
    - begin: \{
      beginCaptures:
        '0': { name: punctuation.curlybrace.open.k }
      end: \}
      endCaptures:
        '0': { name: punctuation.curlybrace.close.k }
      patterns:
      - include: '#declarations'
      - include: '#using-directive'
      - include: '#punctuation-semicolon'

  storage-modifier:
    name: 'storage.modifier.k'
    match: (?<!\.)\b(new|public|protected|internal|private|abstract|virtual|override|sealed|static|partial|readonly|volatile|const|extern|async|unsafe|ref)\b

  class-declaration:
    begin: (?=\bclass\b)
    end: (?<=\})
    patterns:
    - begin: |-
        (?x)
        \b(class)\b\s+
        (@?[_[:alpha:]][_[:alnum:]]*)\s*
      beginCaptures:
        '1': { name: keyword.other.class.k }
        '2': { name: entity.name.type.class.k }
      end: (?=\{)
      patterns:
      - include: '#comment'
      - include: '#type-parameter-list'
      - include: '#base-types'
      - include: '#generic-constraints'
    - begin: \{
      beginCaptures:
        '0': { name: punctuation.curlybrace.open.k }
      end: \}
      endCaptures:
        '0': { name: punctuation.curlybrace.close.k }
      patterns:
      - include: '#class-or-struct-members'
    - include: '#preprocessor'
    - include: '#comment'

  delegate-declaration:
    begin: |-
      (?x)
      (?:\b(delegate)\b)\s+
      (?<type_name>
        (?:
          (?:ref\s+(?:readonly\s+)?)?   # ref return
          (?:
            (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
            (?<name_and_type_args> # identifier + type arguments (if any)
              \g<identifier>\s*
              (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
            )
            (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
            (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
          )
          (?:\s*\?\s*)? # nullable suffix?
          (?:\s* # array suffix?
            \[
              (?:\s*,\s*)* # commata for multi-dimensional arrays
            \]
            \s*
            (?:\?)? # arrays can be nullable reference types
            \s*
          )*
        )
      )\s+
      (\g<identifier>)\s*
      (<([^<>]+)>)?\s*
      (?=\()
    beginCaptures:
      '1': { name: keyword.other.delegate.k }
      '2':
        patterns:
        - include: '#type'
      # '3': ?<identifier> is a sub-expression. Its final value is not considered.
      # '4': ?<name_and_type_args> is a sub-expression. Its final value is not considered.
      # '5': ?<type_args> is a sub-expression. Its final value is not considered.
      # '6': ?<tuple> is a sub-expression. Its final value is not considered.
      '7': { name: entity.name.type.delegate.k }
      '8':
        patterns:
        - include: '#type-parameter-list'
    end: (?=;)
    patterns:
    - include: '#comment'
    - include: '#parenthesized-parameter-list'
    - include: '#generic-constraints'

  enum-declaration:
    begin: (?=\benum\b)
    end: (?<=\})
    patterns:
    - begin: (?=enum)
      end: (?=\{)
      patterns:
      - include: '#comment'
      - match: (enum)\s+(@?[_[:alpha:]][_[:alnum:]]*)
        captures:
          '1': { name: keyword.other.enum.k }
          '2': { name: entity.name.type.enum.k }
      - begin: ':'
        beginCaptures:
          '0': { name: punctuation.separator.colon.k }
        end: (?=\{)
        patterns:
        - include: '#type'
    - begin: \{
      beginCaptures:
        '0': { name: punctuation.curlybrace.open.k }
      end: \}
      endCaptures:
        '0': { name: punctuation.curlybrace.close.k }
      patterns:
      - include: '#preprocessor'
      - include: '#comment'
      - include: '#attribute-section'
      - include: '#punctuation-comma'
      - begin: '@?[_[:alpha:]][_[:alnum:]]*'
        beginCaptures:
          '0': { name: entity.name.variable.enum-member.k }
        end: (?=(,|\}))
        patterns:
        - include: '#comment'
        - include: '#variable-initializer'
    - include: '#preprocessor'
    - include: '#comment'

  interface-declaration:
    begin: (?=\binterface\b)
    end: (?<=\})
    patterns:
    - begin: |-
        (?x)
        (interface)\b\s+
        (@?[_[:alpha:]][_[:alnum:]]*)
      beginCaptures:
        '1': { name: keyword.other.interface.k }
        '2': { name: entity.name.type.interface.k }
      end: (?=\{)
      patterns:
      - include: '#comment'
      - include: '#type-parameter-list'
      - include: '#base-types'
      - include: '#generic-constraints'
    - begin: \{
      beginCaptures:
        '0': { name: punctuation.curlybrace.open.k }
      end: \}
      endCaptures:
        '0': { name: punctuation.curlybrace.close.k }
      patterns:
      - include: '#interface-members'
    - include: '#preprocessor'
    - include: '#comment'

  record-declaration:
    begin: (?=\brecord\b)
    end: (?<=\})
    patterns:
    - begin: |-
        (?x)
        (record)\b\s+
        (@?[_[:alpha:]][_[:alnum:]]*)
      beginCaptures:
        '1': { name: keyword.other.record.k }
        '2': { name: entity.name.type.record.k }
      end: (?=\{)
      patterns:
      - include: '#comment'
      - include: '#type-parameter-list'
      - include: '#base-types'
      - include: '#generic-constraints'
    - begin: \{
      beginCaptures:
        '0': { name: punctuation.curlybrace.open.k }
      end: \}
      endCaptures:
        '0': { name: punctuation.curlybrace.close.k }
      patterns:
      - include: '#class-or-struct-members'
    - include: '#preprocessor'
    - include: '#comment'

  struct-declaration:
    begin: (?=\bstruct\b)
    end: (?<=\})
    patterns:
    - begin: |-
        (?x)
        (struct)\b\s+
        (@?[_[:alpha:]][_[:alnum:]]*)
      beginCaptures:
        '1': { name: keyword.other.struct.k }
        '2': { name: entity.name.type.struct.k }
      end: (?=\{)
      patterns:
      - include: '#comment'
      - include: '#type-parameter-list'
      - include: '#base-types'
      - include: '#generic-constraints'
    - begin: \{
      beginCaptures:
        '0': { name: punctuation.curlybrace.open.k }
      end: \}
      endCaptures:
        '0': { name: punctuation.curlybrace.close.k }
      patterns:
      - include: '#class-or-struct-members'
    - include: '#preprocessor'
    - include: '#comment'

  type-parameter-list:
    begin: \<
    beginCaptures:
      '0': { name: punctuation.definition.typeparameters.begin.k }
    end: \>
    endCaptures:
      '0': { name: punctuation.definition.typeparameters.end.k }
    patterns:
    - match: \b(in|out)\b
      captures:
        '1': { name: storage.modifier.k }
    - match: (@?[_[:alpha:]][_[:alnum:]]*)\b
      captures:
        '1': { name: entity.name.type.type-parameter.k }
    - include: '#comment'
    - include: '#punctuation-comma'
    - include: '#attribute-section'

  base-types:
    begin: ':'
    beginCaptures:
      '0': { name: punctuation.separator.colon.k }
    end: (?=\{|where)
    patterns:
    - include: '#type'
    - include: '#punctuation-comma'
    - include: '#preprocessor'

  generic-constraints:
    begin: (where)\s+(@?[_[:alpha:]][_[:alnum:]]*)\s*(:)
    beginCaptures:
      '1': { name: keyword.other.where.k }
      '2': { name: storage.type.k }
      '3': { name: punctuation.separator.colon.k }
    end: (?=\{|where|;|=>)
    patterns:
    - name: keyword.other.class.k
      match: \bclass\b
    - name: keyword.other.struct.k
      match: \bstruct\b
    - match: (new)\s*(\()\s*(\))
      captures:
        '1': { name: keyword.other.new.k }
        '2': { name: punctuation.parenthesis.open.k }
        '3': { name: punctuation.parenthesis.close.k }
    - include: '#type'
    - include: '#punctuation-comma'
    - include: '#generic-constraints'

  field-declaration:
    begin: |-
      (?x)
      (?<type_name>
        (?:
          (?:
            (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
            (?<name_and_type_args> # identifier + type arguments (if any)
              \g<identifier>\s*
              (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
            )
            (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
            (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
          )
          (?:\s*\?\s*)? # nullable suffix?
          (?:\s* # array suffix?
            \[
              (?:\s*,\s*)* # commata for multi-dimensional arrays
            \]
            \s*
            (?:\?)? # arrays can be nullable reference types
            \s*
          )*
        )
      )\s+
      (\g<identifier>)\s* # first field name
      (?!=>|==)(?=,|;|=|$)
    beginCaptures:
      '1':
        patterns:
        - include: '#type'
      # '2': ?<identifier> is a sub-expression. Its final value is not considered.
      # '3': ?<name_and_type_args> is a sub-expression. Its final value is not considered.
      # '4': ?<type_args> is a sub-expression. Its final value is not considered.
      # '5': ?<tuple> is a sub-expression. Its final value is not considered.
      '6': { name: entity.name.variable.field.k }
    end: (?=;)
    patterns:
    - name: entity.name.variable.field.k
      match: '@?[_[:alpha:]][_[:alnum:]]*'
    - include: '#punctuation-comma'
    - include: '#comment'
    - include: '#variable-initializer'
    - include: '#class-or-struct-members'

  property-declaration:
    begin: |-
      (?x)
      # The negative lookahead below ensures that we don't match nested types
      # or other declarations as properties.
      (?![[:word:][:space:]]*\b(?:class|interface|struct|enum|event)\b)
      (?<return_type>
        (?<type_name>
          (?:
            (?:ref\s+(?:readonly\s+)?)?   # ref return
            (?:
              (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
              (?<name_and_type_args> # identifier + type arguments (if any)
                \g<identifier>\s*
                (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
              )
              (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
              (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
            )
            (?:\s*\?\s*)? # nullable suffix?
            (?:\s* # array suffix?
              \[
                (?:\s*,\s*)* # commata for multi-dimensional arrays
              \]
              \s*
              (?:\?)? # arrays can be nullable reference types
              \s*
            )*
          )
        )\s+
      )
      (?<interface_name>\g<type_name>\s*\.\s*)?
      (?<property_name>\g<identifier>)\s*
      (?=\{|=>|$)
    beginCaptures:
      '1':
        patterns:
        - include: '#type'
      # '2': ?<type_name> is a sub-expression. Its final value is not considered.
      # '3': ?<identifier> is a sub-expression. Its final value is not considered.
      # '4': ?<name_and_type_args> is a sub-expression. Its final value is not considered.
      # '5': ?<type_args> is a sub-expression. Its final value is not considered.
      # '6': ?<tuple> is a sub-expression. Its final value is not considered.
      '7':
        patterns:
        - include: '#type'
        - include: '#punctuation-accessor'
      '8': { name: entity.name.variable.property.k }
    end: (?<=\})|(?=;)
    patterns:
    - include: '#comment'
    - include: '#property-accessors'
    - include: '#expression-body'
    - include: '#variable-initializer'
    - include: '#class-or-struct-members'

  indexer-declaration:
    begin: |-
      (?x)
      (?<return_type>
        (?<type_name>
          (?:
            (?:ref\s+(?:readonly\s+)?)?   # ref return
            (?:
              (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
              (?<name_and_type_args> # identifier + type arguments (if any)
                \g<identifier>\s*
                (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
              )
              (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
              (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
            )
            (?:\s*\?\s*)? # nullable suffix?
            (?:\s* # array suffix?
              \[
                (?:\s*,\s*)* # commata for multi-dimensional arrays
              \]
              \s*
              (?:\?)? # arrays can be nullable reference types
              \s*
            )*
          )
        )\s+
      )
      (?<interface_name>\g<type_name>\s*\.\s*)?
      (?<indexer_name>this)\s*
      (?=\[)
    beginCaptures:
      '1':
        patterns:
        - include: '#type'
      # '2': ?<type_name> is a sub-expression. Its final value is not considered.
      # '3': ?<identifier> is a sub-expression. Its final value is not considered.
      # '4': ?<name_and_type_args> is a sub-expression. Its final value is not considered.
      # '5': ?<type_args> is a sub-expression. Its final value is not considered.
      # '6': ?<tuple> is a sub-expression. Its final value is not considered.
      '7':
        patterns:
        - include: '#type'
        - include: '#punctuation-accessor'
      '8':
        name: keyword.other.this.k
    end: (?<=\})|(?=;)
    patterns:
    - include: '#comment'
    - include: '#bracketed-parameter-list'
    - include: '#property-accessors'
    - include: '#expression-body'
    - include: '#variable-initializer'

  event-declaration:
    begin: |-
      (?x)
      \b(event)\b\s*
      (?<return_type>
        (?<type_name>
          (?:
            (?:
              (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
              (?<name_and_type_args> # identifier + type arguments (if any)
                \g<identifier>\s*
                (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
              )
              (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
              (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
            )
            (?:\s*\?\s*)? # nullable suffix?
            (?:\s* # array suffix?
              \[
                (?:\s*,\s*)* # commata for multi-dimensional arrays
              \]
              \s*
              (?:\?)? # arrays can be nullable reference types
              \s*
            )*
          )
        )\s+
      )
      (?<interface_name>\g<type_name>\s*\.\s*)?
      (?<event_names>\g<identifier>(?:\s*,\s*\g<identifier>)*)\s*
      (?=\{|;|$)
    beginCaptures:
      '1': { name: keyword.other.event.k }
      '2':
        patterns:
        - include: '#type'
      # '3': ?<type_name> is a sub-expression. Its final value is not considered.
      # '4': ?<identifier> is a sub-expression. Its final value is not considered.
      # '5': ?<name_and_type_args> is a sub-expression. Its final value is not considered.
      # '6': ?<type_args> is a sub-expression. Its final value is not considered.
      # '7': ?<tuple> is a sub-expression. Its final value is not considered.
      '8':
        patterns:
        - include: '#type'
        - include: '#punctuation-accessor'
      '9':
        patterns:
        - name: entity.name.variable.event.k
          match: '@?[_[:alpha:]][_[:alnum:]]*'
        - include: '#punctuation-comma'
    end: (?<=\})|(?=;)
    patterns:
    - include: '#comment'
    - include: '#event-accessors'
    - include: '#punctuation-comma'

  property-accessors:
    begin: \{
    beginCaptures:
      '0': { name: punctuation.curlybrace.open.k }
    end: \}
    endCaptures:
      '0': { name: punctuation.curlybrace.close.k }
    patterns:
    - name: storage.modifier.k
      match: \b(private|protected|internal)\b
    - name: keyword.other.get.k
      match: \b(get)\b
    - name: keyword.other.set.k
      match: \b(set)\b
    - name: keyword.other.init.k
      match: \b(init)\b
    - include: '#comment'
    - include: '#attribute-section'
    - include: '#expression-body'
    - include: '#block'
    - include: '#punctuation-semicolon'

  event-accessors:
    begin: \{
    beginCaptures:
      '0': { name: punctuation.curlybrace.open.k }
    end: \}
    endCaptures:
      '0': { name: punctuation.curlybrace.close.k }
    patterns:
    - name: keyword.other.add.k
      match: \b(add)\b
    - name: keyword.other.remove.k
      match: \b(remove)\b
    - include: '#comment'
    - include: '#attribute-section'
    - include: '#expression-body'
    - include: '#block'
    - include: '#punctuation-semicolon'

  method-declaration:
    begin: |-
      (?x)
      (?<return_type>
        (?<type_name>
          (?:
            (?:ref\s+(?:readonly\s+)?)?   # ref return
            (?:
              (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
              (?<name_and_type_args> # identifier + type arguments (if any)
                \g<identifier>\s*
                (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
              )
              (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
              (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
            )
            (?:\s*\?\s*)? # nullable suffix?
            (?:\s* # array suffix?
              \[
                (?:\s*,\s*)* # commata for multi-dimensional arrays
              \]
              \s*
              (?:\?)? # arrays can be nullable reference types
              \s*
            )*
          )
        )\s+
      )
      (?<interface_name>\g<type_name>\s*\.\s*)?
      (\g<identifier>)\s*
      (<([^<>]+)>)?\s*
      (?=\()
    beginCaptures:
      '1':
        patterns:
        - include: '#type'
      # '2': ?<type_name> is a sub-expression. Its final value is not considered.
      # '3': ?<identifier> is a sub-expression. Its final value is not considered.
      # '4': ?<name_and_type_args> is a sub-expression. Its final value is not considered.
      # '5': ?<type_args> is a sub-expression. Its final value is not considered.
      # '6': ?<tuple> is a sub-expression. Its final value is not considered.
      '7':
        patterns:
        - include: '#type'
        - include: '#punctuation-accessor'
      '8': { name: entity.name.function.k }
      '9':
        patterns:
        - include: '#type-parameter-list'
    end: (?<=\})|(?=;)
    patterns:
    - include: '#comment'
    - include: '#parenthesized-parameter-list'
    - include: '#generic-constraints'
    - include: '#expression-body'
    - include: '#block'

  constructor-declaration:
    begin: (?=@?[_[:alpha:]][_[:alnum:]]*\s*\()
    end: (?<=\})|(?=;)
    patterns:
    - match: (@?[_[:alpha:]][_[:alnum:]]*)\b
      captures:
        '1': { name: entity.name.function.k }
    - begin: (:)
      beginCaptures:
        '1': { name: punctuation.separator.colon.k }
      end: (?=\{|=>)
      patterns:
      - include: '#constructor-initializer'
    - include: '#parenthesized-parameter-list'
    - include: '#preprocessor'
    - include: '#comment'
    - include: '#expression-body'
    - include: '#block'

  constructor-initializer:
    begin: \b(?:(base)|(this))\b\s*(?=\()
    beginCaptures:
      '1': { name: keyword.other.base.k }
      '2': { name: keyword.other.this.k }
    end: (?<=\))
    patterns:
    - include: "#argument-list"

  destructor-declaration:
    begin: (~)(@?[_[:alpha:]][_[:alnum:]]*)\s*(?=\()
    beginCaptures:
      '1': { name: punctuation.tilde.k }
      '2': { name: entity.name.function.k }
    end: (?<=\})|(?=;)
    patterns:
    - include: '#comment'
    - include: '#parenthesized-parameter-list'
    - include: '#expression-body'
    - include: '#block'

  operator-declaration:
    begin: |-
      (?x)
      (?<type_name>
        (?:
          (?:ref\s+(?:readonly\s+)?)?   # ref return
          (?:
            (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
            (?<name_and_type_args> # identifier + type arguments (if any)
              \g<identifier>\s*
              (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
            )
            (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
            (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
          )
          (?:\s*\?\s*)? # nullable suffix?
          (?:\s* # array suffix?
            \[
              (?:\s*,\s*)* # commata for multi-dimensional arrays
            \]
            \s*
            (?:\?)? # arrays can be nullable reference types
            \s*
          )*
        )
      )\s*
      (?<operator_keyword>(?:\b(?:operator)))\s*
      (?<operator>(?:\+|-|\*|/|%|&|\||\^|\<\<|\>\>|==|!=|\>|\<|\>=|\<=|!|~|\+\+|--|true|false))\s*
      (?=\()
    beginCaptures:
      '1':
        patterns:
        - include: '#type'
      # '2': ?<identifier> is a sub-expression. Its final value is not considered.
      # '3': ?<name_and_type_args> is a sub-expression. Its final value is not considered.
      # '4': ?<type_args> is a sub-expression. Its final value is not considered.
      # '5': ?<tuple> is a sub-expression. Its final value is not considered.
      '6': { name: keyword.other.operator-decl.k }
      '7': { name: entity.name.function.k }
    end: (?<=\})|(?=;)
    patterns:
    - include: '#comment'
    - include: '#parenthesized-parameter-list'
    - include: '#expression-body'
    - include: '#block'

  conversion-operator-declaration:
    begin: |-
      (?x)
      (?<explicit_or_implicit_keyword>(?:\b(?:explicit|implicit)))\s*
      (?<operator_keyword>(?:\b(?:operator)))\s*
      (?<type_name>
        (?:
          (?:ref\s+(?:readonly\s+)?)?   # ref return
          (?:
            (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
            (?<name_and_type_args> # identifier + type arguments (if any)
              \g<identifier>\s*
              (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
            )
            (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
            (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
          )
          (?:\s*\?\s*)? # nullable suffix?
          (?:\s* # array suffix?
            \[
              (?:\s*,\s*)* # commata for multi-dimensional arrays
            \]
            \s*
            (?:\?)? # arrays can be nullable reference types
            \s*
          )*
        )
      )\s*
      (?=\()
    beginCaptures:
      '1':
        patterns:
        - match: \b(explicit)\b
          captures:
            '1': { name: keyword.other.explicit.k }
        - match: \b(implicit)\b
          captures:
            '1': { name: keyword.other.implicit.k }
      '2': { name: keyword.other.operator-decl.k }
      '3':
        patterns:
        - include: '#type'
    end: (?<=\})|(?=;)
    patterns:
    - include: '#comment'
    - include: '#parenthesized-parameter-list'
    - include: '#expression-body'
    - include: '#block'

  block:
    begin: \{
    beginCaptures:
      '0': { name: punctuation.curlybrace.open.k }
    end: \}
    endCaptures:
      '0': { name: punctuation.curlybrace.close.k }
    patterns:
    - include: '#statement'

  variable-initializer:
    begin: (?<!=|!)(=)(?!=|>)
    beginCaptures:
      '1': { name: keyword.operator.assignment.k }
    end: (?=[,\)\];}])
    patterns:
    - include: '#ref-modifier'
    - include: '#expression'

  expression-body:
    begin: =>
    beginCaptures:
      '0': { name: keyword.operator.arrow.k }
    end: (?=[,\);}])
    patterns:
    - include: '#ref-modifier'
    - include: '#expression'

  goto-statement:
    begin: (?<!\.)\b(goto)\b
    beginCaptures:
      '1': { name: keyword.control.goto.k }
    end: (?=;)
    patterns:
    - begin: \b(case)\b
      beginCaptures:
        '1': { name: keyword.control.case.k }
      end: (?=;)
      patterns:
      - include: '#expression'
    - match: \b(default)\b
      captures:
        '1': { name: keyword.control.default.k }
    - name: entity.name.label.k
      match: '@?[_[:alpha:]][_[:alnum:]]*'

  return-statement:
    begin: (?<!\.)\b(return)\b
    beginCaptures:
      '1': { name: keyword.control.flow.return.k }
    end: (?=;)
    patterns:
    - include: '#ref-modifier'
    - include: '#expression'

  break-or-continue-statement:
    match: (?<!\.)\b(?:(break)|(continue))\b
    captures:
      '1': { name: keyword.control.flow.break.k }
      '2': { name: keyword.control.flow.continue.k }

  throw-statement:
    begin: (?<!\.)\b(throw)\b
    beginCaptures:
      '1': { name: keyword.control.flow.throw.k }
    end: (?=;)
    patterns:
    - include: '#expression'

  yield-statement:
    patterns:
    - include: '#yield-return-statement'
    - include: '#yield-break-statement'

  yield-return-statement:
    begin: (?<!\.)\b(yield)\b\s*\b(return)\b
    beginCaptures:
      '1': { name: keyword.control.flow.yield.k }
      '2': { name: keyword.control.flow.return.k }
    end: (?=;)
    patterns:
    - include: '#expression'

  yield-break-statement:
    match: (?<!\.)\b(yield)\b\s*\b(break)\b
    captures:
      '1': { name: keyword.control.flow.yield.k }
      '2': { name: keyword.control.flow.break.k }

  # Technically, there isn't an "await statement" in the C# grammar. However, including one here makes it easier to handle
  # the scenario where an await-expression will be match by local-declaration first. (e.g. await x;)
  await-statement:
    begin: (?<!\.)\b(await)\b
    beginCaptures:
      '1': { name: keyword.other.await.k }
    end: (?=;)
    patterns:
    - include: '#statement'

  if-statement:
    begin: (?<!\.)\b(if)\b\s*(?=\()
    beginCaptures:
      '1': { name: keyword.control.conditional.if.k }
    end: (?<=\})|(?=;)
    patterns:
    - begin: \(
      beginCaptures:
        '0': { name: punctuation.parenthesis.open.k }
      end: \)
      endCaptures:
        '0': { name: punctuation.parenthesis.close.k }
      patterns:
      - include: '#expression'
    - include: '#statement'

  else-part:
    begin: (?<!\.)\b(else)\b
    beginCaptures:
      '1': { name: keyword.control.conditional.else.k }
    end: (?<=\})|(?=;)
    patterns:
    - include: '#statement'

  switch-statement:
    begin: (?<!\.)\b(switch)\b\s*(?=\()
    beginCaptures:
      '1': { name: keyword.control.switch.k }
    end: (?<=\})
    patterns:
    - begin: \(
      beginCaptures:
        '0': { name: punctuation.parenthesis.open.k }
      end: \)
      endCaptures:
        '0': { name: punctuation.parenthesis.close.k }
      patterns:
      - include: '#expression'
    - begin: \{
      beginCaptures:
        '0': { name: punctuation.curlybrace.open.k }
      end: \}
      endCaptures:
        '0': { name: punctuation.curlybrace.close.k }
      patterns:
      - include: '#switch-label'
      - include: '#statement'

  switch-expression:
    begin: (?x) (?<!\.)\b(switch)\b
    beginCaptures:
      '1': { name: keyword.control.switch.k }
    end: (?<=\})
    endCaptures:
      '0': { name: punctuation.curlybrace.close.k }
    patterns:
    - begin: \{
      beginCaptures:
        '0': { name: punctuation.curlybrace.open.k }
      end: \}
      endCaptures:
        '0': { name: punctuation.curlybrace.close.k }
      patterns:
      - include: '#comment'
      - include: '#literal'
      # - include: '#switch-literal'
      - include: '#switch-var-pattern'
      - include: '#switch-property-expression'
      - include: '#member-access-expression'
      - include: '#switch-pattern'
      - include: '#expression-body'
      - include: '#punctuation-comma'

  switch-pattern:
    begin: |-
      (?x) # e.g. int x OR var x
      (?<type_name>
        (?:
          (?:
            (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
            (?<name_and_type_args> # identifier + type arguments (if any)
              \g<identifier>\s*
              (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
            )
            (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
            (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
          )
          (?:\s*\?\s*)? # nullable suffix?
          (?:\s* # array suffix?
            \[
              (?:\s*,\s*)* # commata for multi-dimensional arrays
            \]
            \s*
            (?:\?)? # arrays can be nullable reference types
            \s*
          )*
        )
      )\s+
      (\g<identifier>)\b\s*
    beginCaptures:
      '1':
        patterns:
        - include: '#type'
      '2': { name: entity.name.variable.local.k }
    end: (?==>)
    patterns:
      - include: '#comment'
      - include: '#switch-when-clause'

  switch-property-expression:
    begin: |-
      (?x) # e.g. int x OR var x
      (?<type_name>
        (?:
          (?:
            (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
            (?<name_and_type_args> # identifier + type arguments (if any)
              \g<identifier>\s*
              (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
            )
            (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
            (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
          )
          (?:\s*\?\s*)? # nullable suffix?
          (?:\s* # array suffix?
            \[
              (?:\s*,\s*)* # commata for multi-dimensional arrays
            \]
            \s*
            (?:\?)? # arrays can be nullable reference types
            \s*
          )*
        )
      )?\s*
      (\{)
    beginCaptures:
      '1':
        patterns:
        - include: '#type'
      # '': { name: punctuation.curlybrace.open.k }
      '6': { name: punctuation.curlybrace.open.k }
    end: \}
    endCaptures:
      '0': { name: punctuation.curlybrace.close.k }
    patterns:
    - include: '#expression'
    - include: '#punctuation-comma'

  switch-var-pattern:
    begin: |-
      (?x) # match foreach (var (x, y) in ...)
      (?:\b(var)\b\s*)
      (?<tuple>\((?:[^\(\)]|\g<tuple>)+\))\s*
    beginCaptures:
      '1': { name: keyword.other.var.k }
      '2':
        patterns:
        - include: '#tuple-declaration-deconstruction-element-list'
    end: (?==>)
    patterns:
      - include: '#comment'
      - include: '#switch-when-clause'

  switch-when-clause:
    begin: (?<!\.)\b(when)\b\s*(\()?
    beginCaptures:
      '1': { name: keyword.control.try.when.k }
      '2': { name: punctuation.parenthesis.open.k }
    end: (?==>)
    patterns:
    - include: '#comment'
    - include: '#expression'
    - include: '#punctuation-comma'
    - match: \(
      captures:
        '0': { name: punctuation.parenthesis.open.k }
    - match: \)
      captures:
        '0': { name: punctuation.parenthesis.close.k }

  switch-label:
    patterns:
    - begin: (?<!\.)\b(case)\b\s+
      beginCaptures:
        '1': { name: keyword.control.case.k }
      end: ':'
      endCaptures:
        '0': { name: punctuation.separator.colon.k }
      patterns:
      - include: '#expression'
    - match: (?<!\.)\b(default)\b\s*(:)
      captures:
        '1': { name: keyword.control.default.k }
        '2': { name: punctuation.separator.colon.k }

  do-statement:
    begin: (?<!\.)\b(do)\b
    beginCaptures:
      '1': { name: keyword.control.loop.do.k }
    end: (?=;|})
    patterns:
    - include: '#statement'

  kql-statement:
    patterns:
      - include: '#kql-select-statement'
      - include: '#kql-use-volume-statement'
      - include: '#kql-create-statement'
      - include: '#kql-show-statement'
      - include: '#kql-attach-statement'
      - include: '#kql-detach-statement'
      - include: '#kql-delete-statement'
      - include: '#kql-explain-statement'
      - include: '#kql-insert-statement'
      - include: '#kql-update-statement'
      - include: '#kql-import-statement'
      - include: '#kql-export-statement'
      - include: '#kql-copy-volume-statement'

  kql-select-statement:
    begin: (?<!\.)\b(?i:(select))\b\s*(.+)\s*\b(?i:(from))\b\s+\b([_[:alpha:]][_[:alnum:]]*)\b
    beginCaptures:
      '1': { name: keyword.query.select.k }
      '2': { name: entity.name.variable.k }
      '3': { name: keyword.query.from.k }
      '4': { name: entity.name.variable.k }
    end: (?=;)
    patterns:
      - include: '#where-clause'
      - include: '#orderby-clause'
      - include: '#group-clause'

  kql-copy-volume-statement:
    begin: (?<!\.)\b(?i:(copy\svolume))\b\s*(.+)\s*\b(?i:(to))\b\s+\b([_[:alpha:]][_[:alnum:]]*)\b
    beginCaptures:
      '1': { name: keyword.query.copy-volume.k }
      '3': { name: keyword.query.to.k }
      '4': { name: entity.name.variable.k }
    end: (?=;)

  kql-import-statement:
    begin: (?<!\.)\b(?i:(import\sfile|import\sfiles))\b\s*(.+)\s*\b(?i:(to))\b\s+\b([_[:alpha:]][_[:alnum:]]*)\b
    beginCaptures:
      '1': { name: keyword.query.import.k }
      '3': { name: keyword.query.to.k }
    end: (?=;)

  kql-export-statement:
    begin: (?<!\.)\b(?i:(export\srecords\sfrom))\b\s+\b([_[:alpha:]][_[:alnum:]]*)\b
    beginCaptures:
      '1': { name: keyword.query.export.k }
      '2': { name: entity.name.variable.k }
    end: (?=;)
    patterns:
      - include: '#where-clause'
      - include: '#kql-to-entity'

  kql-insert-statement:
    begin: (?<!\.)\b(?i:(insert))\b\s*\b(?i:(into))\b\s+\b([_[:alpha:]][_[:alnum:]]*)\b
    beginCaptures:
      '1': { name: keyword.query.insert.k }
      '2': { name: keyword.query.into.k }
      '3': { name: entity.name.variable.k }
    end: (?=;)
    patterns:
      - include: '#kql-set-clause'

  kql-set-clause:
    begin: |-
      (?x)
      \b(set)\b\s*
      (@?[_[:alpha:]][_[:alnum:]]*)\b\s*
      (=)\s*
    beginCaptures:
      '1': { name: keyword.query.set.k }
      '2': { name: entity.name.variable.range-variable.k }
      '3': { name: keyword.operator.assignment.k }
    end: (?=;)
    patterns:
    - include: '#query-body'
    - include: '#expression'

  kql-update-statement:
    begin: (?<!\.)\b(?i:(update))\b\s*\b([_[:alpha:]][_[:alnum:]]*)\b
    beginCaptures:
      '1': { name: keyword.query.update.k }
      '2': { name: entity.name.variable.k }
    end: (?=;)
    patterns:
      - include: '#kql-set-clause'
      - include: '#where-clause'

  kql-delete-statement:
    begin: (?<!\.)\b(?i:(delete|undelete))\b\s*(.*)\s*\b(?i:(from))\b\s+\b([_[:alpha:]][_[:alnum:]]*)\b
    beginCaptures:
      '1': { name: keyword.query.delete.k }
      '3': { name: keyword.query.from.k }
    end: (?=;)
    patterns:
      - include: '#where-clause'

  kql-use-volume-statement:
    begin: (?<!\.)\b(?i:(use))\b\s*(?i:(volume))\s*\b([_[:alpha:]][_[:alnum:]]*)\b\s*
    beginCaptures:
      '1': { name: keyword.query.use.k }
      '2': { name: keyword.query.volume.k }
      '3': { name: entity.name.variable.k }
    end: (?=;)

  kql-create-statement:
    begin: (?<!\.)\b(?i:(create|drop|rename|alter|truncate))\b\s*(?i:(volume|table|snapshot|index|gateway))\s*\b([_[:alpha:]][_[:alnum:]]*)\b\s*
    beginCaptures:
      '1': { name: keyword.query.create_drop.k }
      '2': { name: keyword.query.entity.k }
      '3': { name: entity.name.variable.k }
    end: (?=;)

  kql-show-statement:
    begin: (?<!\.)\b(?i:(show))\b\s*(?i:(volumes|tables|schedules|conf|privileges))
    beginCaptures:
      '1': { name: keyword.query.show.k }
      '2': { name: keyword.query.entity.k }
    end: (?=;)
    patterns:
      - include: '#kql-options-more'

  kql-explain-statement:
    begin: (?<!\.)\b(?i:(explain))\b\s*([_[:alpha:]][_[:alnum:]]*)
    beginCaptures:
      '1': { name: keyword.query.explain.k }
      '2': { name: entity.name.variable.k }
    end: (?=;)
    patterns:
      - include: '#kql-options-more'
  
  kql-options-more:
    match: \b(?i:(more))\b
    captures:
      '1': { name: keyword.query.more.k }

  kql-attach-statement:
    begin: (?<!\.)\b(?i:(attach|reload))\b\s+
    beginCaptures:
      '1': { name: keyword.query.attach.k }
    end: (?=;)
    patterns:
      - include: '#kql-attach-type'
      - include: '#kql-to-entity'

  kql-detach-statement:
    begin: (?<!\.)\b(?i:(detach))\b\s+
    beginCaptures:
      '1': { name: keyword.query.detach.k }
    end: (?=;)
    patterns:
      - include: '#kql-attach-type'
      - include: '#kql-from-entity'

  kql-attach-type:
    match: \b(?i:(schedule|field\s+key\s+cache|key\s+order\s+cache|truncation\s+cache))\b\s*
    captures:
      '1': { name: keyword.query.entity.k }

  kql-to-entity:
    match: \b(?i:(to))\b\s+([_[:alpha:]][_[:alnum:]]*)
    captures:
      '1': { name: keyword.query.to.k }
      '2': { name: entity.name.variable.k }
  
  kql-from-entity:
    match: \b(?i:(from))\b\s+([_[:alpha:]][_[:alnum:]]*)
    captures:
      '1': { name: keyword.query.from.k }
      '2': { name: entity.name.variable.k }
  
  while-statement:
    begin: (?<!\.)\b(while)\b\s*(?=\()
    beginCaptures:
      '1': { name: keyword.control.loop.while.k }
    end: (?<=\})|(?=;)
    patterns:
    - begin: \(
      beginCaptures:
        '0': { name: punctuation.parenthesis.open.k }
      end: \)
      endCaptures:
        '0': { name: punctuation.parenthesis.close.k }
      patterns:
      - include: '#expression'
    - include: '#statement'

  for-in-statement:
    begin: (?<!\.)\b(for)\b\s*\b([_[:alpha:]][_[:alnum:]]*)\b\s+\b
    beginCaptures:
      '1': { name: keyword.control.loop.for.k }
      '2': { name: variable.other.readwrite.k }
    end: (?<=\})|(?=;)
    patterns:
    - begin: (?:\b(in)\b)
      beginCaptures:
        '1': {name: keyword.control.loop.in.k}
      end: (\{)
      endCaptures:
        '1': {name: punctuation.curlybrace.open.k}
      patterns:
        - include: '#expression'
    - include: '#statement'

  for-to-statement:
    begin: (?<!\.)\b(for)\b\s*\b([_[:alpha:]][_[:alnum:]]*)\s*=\s*([[:digit:]]+)\b\s+\b
    beginCaptures:
      '1': { name: keyword.control.loop.for.k }
      '2': { name: variable.other.readwrite.k }
    end: (?<=\})|(?=;)
    patterns:
    - begin: (?:\b(to)\b)
      beginCaptures:
        '1': {name: keyword.control.loop.to.k}
      end: (\{)
      endCaptures:
        '1': {name: punctuation.curlybrace.open.k}
      patterns:
        - include: '#expression'
    - include: '#statement'

  for-statement:
    begin: (?<!\.)\b(for)\b\s*(?=\()
    beginCaptures:
      '1': { name: keyword.control.loop.for.k }
    end: (?<=\})|(?=;)
    patterns:
    - begin: \(
      beginCaptures:
        '0': { name: punctuation.parenthesis.open.k }
      end: \)
      endCaptures:
        '0': { name: punctuation.parenthesis.close.k }
      patterns:
      - include: '#local-variable-declaration'
      - include: '#expression'
      - include: '#punctuation-comma'
      - include: '#punctuation-semicolon'
    - include: '#statement'

  foreach-statement:
    begin: (?<!\.)\b(foreach)\b\s*(?=\()
    beginCaptures:
      '1': { name: keyword.control.loop.foreach.k }
    end: (?<=\})|(?=;)
    patterns:
    - begin: \(
      beginCaptures:
        '0': { name: punctuation.parenthesis.open.k }
      end: \)
      endCaptures:
        '0': { name: punctuation.parenthesis.close.k }
      patterns:
      - match: |-
          (?x)
          (?:
            (\bvar\b)|
            (?<type_name>
              (?:
                (?:
                  (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
                  (?<name_and_type_args> # identifier + type arguments (if any)
                    \g<identifier>\s*
                    (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
                  )
                  (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
                  (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
                )
                (?:\s*\?\s*)? # nullable suffix?
                (?:\s* # array suffix?
                  \[
                    (?:\s*,\s*)* # commata for multi-dimensional arrays
                  \]
                  \s*
                  (?:\?)? # arrays can be nullable reference types
                  \s*
                )*
              )
            )
          )\s+
          (\g<identifier>)\s+
          \b(in)\b
        captures:
          '1': { name: keyword.other.var.k }
          '2':
            patterns:
            - include: '#type'
          # '3': ?<identifier> is a sub-expression. Its final value is not considered.
          # '4': ?<name_and_type_args> is a sub-expression. Its final value is not considered.
          # '5': ?<type_args> is a sub-expression. Its final value is not considered.
          # '6': ?<tuple> is a sub-expression. Its final value is not considered.
          '7': { name: entity.name.variable.local.k }
          '8': { name: keyword.control.loop.in.k }
      - match: |-
          (?x) # match foreach (var (x, y) in ...)
          (?:\b(var)\b\s*)?
          (?<tuple>\((?:[^\(\)]|\g<tuple>)+\))\s+
          \b(in)\b
        captures:
          '1': { name: keyword.other.var.k }
          '2':
            patterns:
            - include: '#tuple-declaration-deconstruction-element-list'
          '3': { name: keyword.control.loop.in.k }
      - include: '#expression'
    - include: '#statement'

  try-statement:
    patterns:
    - include: '#try-block'
    - include: '#catch-clause'
    - include: '#finally-clause'

  try-block:
    begin: (?<!\.)\b(try)\b
    beginCaptures:
      '1': { name: keyword.control.try.k }
    end: (?<=\})
    patterns:
    - include: '#comment'
    - include: '#block'

  finally-clause:
    begin: (?<!\.)\b(finally)\b
    beginCaptures:
      '1': { name: keyword.control.try.finally.k }
    end: (?<=\})
    patterns:
    - include: '#comment'
    - include: '#block'

  catch-clause:
    begin: (?<!\.)\b(catch)\b
    beginCaptures:
        '1': { name: keyword.control.try.catch.k }
    end: (?<=\})
    patterns:
    - begin: \(
      beginCaptures:
        '0': { name: punctuation.parenthesis.open.k }
      end: \)
      endCaptures:
        '0': { name: punctuation.parenthesis.close.k }
      patterns:
      - match: |-
          (?x)
          (?<type_name>
            (?:
              (?:
                (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
                (?<name_and_type_args> # identifier + type arguments (if any)
                  \g<identifier>\s*
                  (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
                )
                (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
                (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
              )
              (?:\s*\?\s*)? # nullable suffix?
              (?:\s* # array suffix?
                \[
                  (?:\s*,\s*)* # commata for multi-dimensional arrays
                \]
                \s*
                (?:\?)? # arrays can be nullable reference types
                \s*
              )*
            )
          )\s*
          (?:(\g<identifier>)\b)?
        captures:
          '1':
            patterns:
            - include: '#type'
          # '2': ?<identifier> is a sub-expression. Its final value is not considered.
          # '3': ?<name_and_type_args> is a sub-expression. Its final value is not considered.
          # '4': ?<type_args> is a sub-expression. Its final value is not considered.
          # '5': ?<tuple> is a sub-expression. Its final value is not considered.
          '6': { name: entity.name.variable.local.k }
    - include: '#when-clause'
    - include: '#comment'
    - include: '#block'

  when-clause:
    begin: (?<!\.)\b(when)\b\s*(\()
    beginCaptures:
      '1': { name: keyword.control.try.when.k }
      '2': { name: punctuation.parenthesis.open.k }
    end: \)
    endCaptures:
      '0': { name: punctuation.parenthesis.close.k }
    patterns:
    - include: '#expression'
    - include: '#comment'

  checked-unchecked-statement:
    begin: (?<!\.)\b(?:(checked)|(unchecked))\b\s*(?!\()
    beginCaptures:
      '1': { name: keyword.other.checked.k }
      '2': { name: keyword.other.unchecked.k }
    end: (?<=\})
    patterns:
    - include: '#block'
    - include: '#comment'

  lock-statement:
    begin: (?<!\.)\b(lock)\b\s*(?=\()
    beginCaptures:
      '1': { name: keyword.other.lock.k }
    end: (?<=\})|(?=;)
    patterns:
    - begin: \(
      beginCaptures:
        '0': { name: punctuation.parenthesis.open.k }
      end: \)
      endCaptures:
        '0': { name: punctuation.parenthesis.close.k }
      patterns:
      - include: '#expression'
    - include: '#statement'

  using-statement:
    begin: (?<!\.)\b(using)\b\s*(?=\()
    beginCaptures:
      '1': { name: keyword.other.using.k }
    end: (?=\;|})
    patterns:
    - begin: \(
      beginCaptures:
        '0': { name: punctuation.parenthesis.open.k }
      end: \)
      endCaptures:
        '0': { name: punctuation.parenthesis.close.k }
      patterns:
      - include: '#local-variable-declaration'
      - include: '#expression'
    - include: '#statement'

  labeled-statement:
    match: '(@?[_[:alpha:]][_[:alnum:]]*)\s*(:)'
    captures:
      '1': { name: entity.name.label.k }
      '2': { name: punctuation.separator.colon.k }

  local-declaration:
    patterns:
    - include: '#local-constant-declaration'
    - include: '#local-variable-declaration'
    - include: '#local-function-declaration'
    - include: '#local-tuple-var-deconstruction'

  local-variable-declaration:
    begin: |-
      (?x)
      (?:
        (?:(\busing)\s+)?
        (?:(\bref)\s+(?:(\breadonly)\s+)?)?(\bvar\b)| # ref local
        (?<type_name>
          (?:
            (?:ref\s+(?:readonly\s+)?)?   # ref local
            (?:
              (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
              (?<name_and_type_args> # identifier + type arguments (if any)
                \g<identifier>\s*
                (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
              )
              (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
              (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
            )
            (?:\s*\?\s*)? # nullable suffix?
            (?:\s* # array suffix?
              \[
                (?:\s*,\s*)* # commata for multi-dimensional arrays
              \]
              \s*
              (?:\?)? # arrays can be nullable reference types
              \s*
            )*
          )
        )
      )\s+
      (\g<identifier>)\s*
      (?!=>)
      (?=,|;|=|\))
    beginCaptures:
      '1': { name: keyword.other.using.k }
      '2': { name: storage.modifier.k }
      '3': { name: storage.modifier.k }
      '4': { name: keyword.other.var.k }
      '5':
        patterns:
        - include: '#type'
      # '6': ?<identifier> is a sub-expression. Its final value is not considered.
      # '7': ?<name_and_type_args> is a sub-expression. Its final value is not considered.
      # '8': ?<type_args> is a sub-expression. Its final value is not considered.
      # '9': ?<tuple> is a sub-expression. Its final value is not considered.
      '10': { name: entity.name.variable.local.k }
    end: (?=;|\))
    patterns:
    - name: entity.name.variable.local.k
      match: '@?[_[:alpha:]][_[:alnum:]]*'
    - include: '#punctuation-comma'
    - include: '#comment'
    - include: '#variable-initializer'

  local-constant-declaration:
    begin: |-
      (?x)
      (?<const_keyword>\b(?:const)\b)\s*
      (?<type_name>
        (?:
          (?:
            (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
            (?<name_and_type_args> # identifier + type arguments (if any)
              \g<identifier>\s*
              (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
            )
            (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
            (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
          )
          (?:\s*\?\s*)? # nullable suffix?
          (?:\s* # array suffix?
            \[
              (?:\s*,\s*)* # commata for multi-dimensional arrays
            \]
            \s*
            (?:\?)? # arrays can be nullable reference types
            \s*
          )*
        )
      )\s+
      (\g<identifier>)\s*
      (?=,|;|=)
    beginCaptures:
      '1': { name: storage.modifier.k }
      '2':
        patterns:
        - include: '#type'
      # '3': ?<identifier> is a sub-expression. Its final value is not considered.
      # '4': ?<name_and_type_args> is a sub-expression. Its final value is not considered.
      # '5': ?<type_args> is a sub-expression. Its final value is not considered.
      # '6': ?<tuple> is a sub-expression. Its final value is not considered.
      '7': { name: entity.name.variable.local.k }
    end: (?=;)
    patterns:
    - name: entity.name.variable.local.k
      match: '@?[_[:alpha:]][_[:alnum:]]*'
    - include: '#punctuation-comma'
    - include: '#comment'
    - include: '#variable-initializer'

  local-function-declaration:
    patterns:
      - include: '#method-declaration'

  local-tuple-var-deconstruction:
    begin: |-
      (?x) # e.g. var (x, y) = GetPoint();
      (?:\b(var)\b\s*)
      (?<tuple>\((?:[^\(\)]|\g<tuple>)+\))\s*
      (?=;|=|\))
    beginCaptures:
      '1': { name: keyword.other.var.k }
      '2':
        patterns:
        - include: '#tuple-declaration-deconstruction-element-list'
    end: (?=;|\))
    patterns:
    - include: '#comment'
    - include: '#variable-initializer'

  tuple-deconstruction-assignment:
    match: |-
      (?x)
      (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))\s*
      (?!=>|==)(?==)
    captures:
      '1':
        patterns:
        - include: '#tuple-deconstruction-element-list'

  tuple-declaration-deconstruction-element-list:
    begin: \(
    beginCaptures:
      '0': { name: punctuation.parenthesis.open.k }
    end: \)
    endCaptures:
      '0': { name: punctuation.parenthesis.close.k }
    patterns:
    - include: '#comment'
    - include: '#tuple-declaration-deconstruction-element-list'
    - include: '#declaration-expression-tuple'
    - include: '#punctuation-comma'
    - match: |-
        (?x) # e.g. x
        (@?[_[:alpha:]][_[:alnum:]]*)\b\s*
        (?=[,)])
      captures:
        '1': { name: entity.name.variable.tuple-element.k }
  tuple-deconstruction-element-list:
    begin: \(
    beginCaptures:
      '0': { name: punctuation.parenthesis.open.k }
    end: \)
    endCaptures:
      '0': { name: punctuation.parenthesis.close.k }
    patterns:
    - include: '#comment'
    - include: '#tuple-deconstruction-element-list'
    - include: '#declaration-expression-tuple'
    - include: '#punctuation-comma'
    - match: |-
        (?x) # e.g. x
        (@?[_[:alpha:]][_[:alnum:]]*)\b\s*
        (?=[,)])
      captures:
        '1': { name: variable.other.readwrite.k }
  declaration-expression-local:
    match: |-
      (?x) # e.g. int x OR var x
      (?:
        \b(var)\b|
        (?<type_name>
          (?:
            (?:
              (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
              (?<name_and_type_args> # identifier + type arguments (if any)
                \g<identifier>\s*
                (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
              )
              (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
              (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
            )
            (?:\s*\?\s*)? # nullable suffix?
            (?:\s* # array suffix?
              \[
                (?:\s*,\s*)* # commata for multi-dimensional arrays
              \]
              \s*
              (?:\?)? # arrays can be nullable reference types
              \s*
            )*
          )
        )
      )\s+
      (\g<identifier>)\b\s*
      (?=[,)\]])
    captures:
      '1': { name: keyword.other.var.k }
      '2':
        patterns:
        - include: '#type'
      # '3': ?<identifier> is a sub-expression. Its final value is not considered.
      # '4': ?<name_and_type_args> is a sub-expression. Its final value is not considered.
      # '5': ?<type_args> is a sub-expression. Its final value is not considered.
      # '6': ?<tuple> is a sub-expression. Its final value is not considered.
      '7': { name: entity.name.variable.local.k }

  declaration-expression-tuple:
    match: |-
      (?x) # e.g. int x OR var x
      (?:
        \b(var)\b|
        (?<type_name>
          (?:
            (?:
              (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
              (?<name_and_type_args> # identifier + type arguments (if any)
                \g<identifier>\s*
                (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
              )
              (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
              (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
            )
            (?:\s*\?\s*)? # nullable suffix?
                      (?:\s* # array suffix?
            \[
              (?:\s*,\s*)* # commata for multi-dimensional arrays
            \]
            \s*
            (?:\?)? # arrays can be nullable reference types
            \s*
          )*
          )
        )
      )\s+
      (\g<identifier>)\b\s*
      (?=[,)])
    captures:
      '1': { name: keyword.other.var.k }
      '2':
        patterns:
        - include: '#type'
      # '3': ?<identifier> is a sub-expression. Its final value is not considered.
      # '4': ?<name_and_type_args> is a sub-expression. Its final value is not considered.
      # '5': ?<type_args> is a sub-expression. Its final value is not considered.
      # '6': ?<tuple> is a sub-expression. Its final value is not considered.
      '7': { name: entity.name.variable.tuple-element.k }

  checked-unchecked-expression:
    begin: (?<!\.)\b(?:(checked)|(unchecked))\b\s*(\()
    beginCaptures:
      '1': { name: keyword.other.checked.k }
      '2': { name: keyword.other.unchecked.k }
      '3': { name: punctuation.parenthesis.open.k }
    end: \)
    endCaptures:
      '0': { name: punctuation.parenthesis.close.k }
    patterns:
    - include: '#expression'

  typeof-or-default-expression:
    begin: (?<!\.)\b(?:(typeof)|(default))\b\s*(\()
    beginCaptures:
      '1': { name: keyword.other.typeof.k }
      '2': { name: keyword.other.default.k }
      '3': { name: punctuation.parenthesis.open.k }
    end: \)
    endCaptures:
      '0': { name: punctuation.parenthesis.close.k }
    patterns:
    - include: '#type'

  nameof-expression:
    begin: (?<!\.)\b(nameof)\b\s*(\()
    beginCaptures:
      '1': { name: keyword.other.nameof.k }
      '2': { name: punctuation.parenthesis.open.k }
    end: \)
    endCaptures:
      '0': { name: punctuation.parenthesis.close.k }
    patterns:
    - include: '#expression'

  throw-expression:
    match: (?<!\.)\b(throw)\b
    captures:
      '1': { name: keyword.control.flow.throw.k }

  interpolated-string:
    name: string.quoted.double.k
    begin: '\$"'
    beginCaptures:
      '0': { name: punctuation.definition.string.begin.k }
    end: (")|((?:[^\\\n])$)
    endCaptures:
      '1': { name: punctuation.definition.string.end.k }
      '2': { name: invalid.illegal.newline.k }
    patterns:
    - include: '#string-character-escape'
    - include: '#interpolation'

  verbatim-interpolated-string:
    name: string.quoted.double.k
    begin: '(?:\$@|@\$)"'
    beginCaptures:
      '0': { name: punctuation.definition.string.begin.k }
    end: '"(?=[^"])'
    endCaptures:
      '0': { name: punctuation.definition.string.end.k }
    patterns:
    - include: '#verbatim-string-character-escape'
    - include: '#interpolation'

  interpolation:
    name: meta.interpolation.k
    begin: (?<=[^\{]|^)((?:\{\{)*)(\{)(?=[^\{])
    beginCaptures:
      '1': { name: string.quoted.double.k }
      '2': { name: punctuation.definition.interpolation.begin.k }
    end: \}
    endCaptures:
      '0': { name: punctuation.definition.interpolation.end.k }
    patterns:
    - include: '#expression'

  literal:
    patterns:
    - include: '#boolean-literal'
    - include: '#null-literal'
    - include: '#numeric-literal'
    - include: '#char-literal'
    - include: '#string-3-dquote-literal'
    - include: '#string-literal'
    - include: '#verbatim-string-literal'
    - include: '#tuple-literal'

  boolean-literal:
    patterns:
    - name: constant.language.boolean.true.k
      match: (?<!\.)\btrue\b
    - name: constant.language.boolean.false.k
      match: (?<!\.)\bfalse\b
  null-literal:
    name: constant.language.null.k
    match: (?<!\.)\bnull\b

  numeric-literal:
    match: "(?<!\\w)\\.?\\d(?:(?:[0-9a-zA-Z_\\.]|_)|(?<=[eE])[+-])*"
    captures:
      '0':
        patterns:
        - begin: "(?=.)"
          end: "$"
          patterns:
          # Decimal number (with optional thousands separator) with mandatory decimal part (with optional thousands separator) and optional exponent (also with optional thousands separator)
          - match: "(\\G(?=[0-9.])(?!0[xXbB]))([0-9](?:[0-9]|((?<=[0-9a-fA-F])_(?=[0-9a-fA-F])))*)?((?:(?<=[0-9])|\\.(?=[0-9])))([0-9](?:[0-9]|((?<=[0-9a-fA-F])_(?=[0-9a-fA-F])))*)?((?<!_)([eE])(\\+?)(\\-?)((?:[0-9](?:[0-9]|(?:(?<=[0-9a-fA-F])_(?=[0-9a-fA-F])))*)))?([fFdDmM](?!\\w))?$"
            captures:
              '2':
                name: constant.numeric.decimal.k
                patterns:
                - match: "(?<=[0-9a-fA-F])_(?=[0-9a-fA-F])"
                  name: constant.numeric.other.separator.thousands.k
              '3':
                name: constant.numeric.other.separator.thousands.k
              '4':
                name: constant.numeric.other.separator.decimals.k
              '5':
                name: constant.numeric.decimal.k
                patterns:
                - match: "(?<=[0-9a-fA-F])_(?=[0-9a-fA-F])"
                  name: constant.numeric.other.separator.thousands.k
              '6':
                name: constant.numeric.other.separator.thousands.k
              '8':
                name: constant.numeric.other.exponent.k
              '9':
                name: keyword.operator.arithmetic.k
              '10':
                name: keyword.operator.arithmetic.k
              '11':
                name: constant.numeric.decimal.k
                patterns:
                - match: "(?<=[0-9a-fA-F])_(?=[0-9a-fA-F])"
                  name: constant.numeric.other.separator.thousands.k
              '12':
                name: constant.numeric.other.suffix.k
          # Binary number (with optional thousands separator)
          - match: "(\\G0[bB])([01_](?:[01_]|((?<=[0-9a-fA-F])_(?=[0-9a-fA-F])))*)((?:(?:(?:(?:(?:[uU]|[uU]l)|[uU]L)|l[uU]?)|L[uU]?)|[fFdDmM])(?!\\w))?$"
            captures:
              '1':
                name: constant.numeric.other.preffix.binary.k
              '2':
                name: constant.numeric.binary.k
                patterns:
                - match: "(?<=[0-9a-fA-F])_(?=[0-9a-fA-F])"
                  name: constant.numeric.other.separator.thousands.k
              '3':
                name: constant.numeric.other.separator.thousands.k
              '4':
                name: constant.numeric.other.suffix.k
          # Hexadecimal number (with optional thousands separator)
          - match: "(\\G0[xX])([0-9a-fA-F](?:[0-9a-fA-F]|((?<=[0-9a-fA-F])_(?=[0-9a-fA-F])))*)((?:(?:(?:(?:(?:[uU]|[uU]l)|[uU]L)|l[uU]?)|L[uU]?)|[fFdDmM])(?!\\w))?$"
            captures:
              '1':
                name: constant.numeric.other.preffix.hex.k
              '2':
                name: constant.numeric.hex.k
                patterns:
                - match: "(?<=[0-9a-fA-F])_(?=[0-9a-fA-F])"
                  name: constant.numeric.other.separator.thousands.k
              '3':
                name: constant.numeric.other.separator.thousands.k
              '4':
                name: constant.numeric.other.suffix.k
          # Integral number (with optional thousands separator) with no decimal part and optional exponent (also with optional thousands separator)
          - match: "(\\G(?=[0-9.])(?!0[xXbB]))([0-9](?:[0-9]|((?<=[0-9a-fA-F])_(?=[0-9a-fA-F])))*)((?<!_)([eE])(\\+?)(\\-?)((?:[0-9](?:[0-9]|(?:(?<=[0-9a-fA-F])_(?=[0-9a-fA-F])))*)))?((?:(?:(?:(?:(?:[uU]|[uU]l)|[uU]L)|l[uU]?)|L[uU]?)|[fFdDmM])(?!\\w))?$"
            captures:
              '2':
                name: constant.numeric.decimal.k
                patterns:
                - match: "(?<=[0-9a-fA-F])_(?=[0-9a-fA-F])"
                  name: constant.numeric.other.separator.thousands.k
              '3':
                name: constant.numeric.other.separator.thousands.k
              '5':
                name: constant.numeric.other.exponent.k
              '6':
                name: keyword.operator.arithmetic.k
              '7':
                name: keyword.operator.arithmetic.k
              '8':
                name: constant.numeric.decimal.k
                patterns:
                - match: "(?<=[0-9a-fA-F])_(?=[0-9a-fA-F])"
                  name: constant.numeric.other.separator.thousands.k
              '9':
                name: constant.numeric.other.suffix.k
          # Capture the rest as an invalid numeric literal
          - match: "(?:(?:[0-9a-zA-Z_\\.]|_)|(?<=[eE])[+-])+"
            name: invalid.illegal.constant.numeric.k

  char-literal:
    name: string.quoted.single.k
    begin: "'"
    beginCaptures:
      '0': { name: punctuation.definition.char.begin.k }
    end: (\')|((?:[^\\\n])$)
    endCaptures:
      '1': { name: punctuation.definition.char.end.k }
      '2': { name: invalid.illegal.newline.k }
    patterns:
    - include: '#char-character-escape'

  char-character-escape:
    name: constant.character.escape.k
    match: \\(['"\\0abfnrtv]|x[0-9a-fA-F]{1,4}|u[0-9a-fA-F]{4})
    
  string-3-dquote-literal:
    name: string.quoted.three-double.k
    begin: '(?<!@)"""'
    beginCaptures:
      '0': { name: punctuation.definition.string.begin.k }
    end: (""")
    endCaptures:
      '1': { name: punctuation.definition.string.end.k }
    patterns:
    - include: '#string-character-escape'

  string-literal:
    name: string.quoted.double.k
    begin: '(?<!@)"'
    beginCaptures:
      '0': { name: punctuation.definition.string.begin.k }
    end: (")
    endCaptures:
      '1': { name: punctuation.definition.string.end.k }
      #'2': { name: invalid.illegal.newline.k }
    patterns:
    - include: '#string-character-escape'

  string-character-escape:
    name: constant.character.escape.k
    match: \\(['"\\0abfnrtv]|x[0-9a-fA-F]{1,4}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4})

  verbatim-string-literal:
    name: string.quoted.double.k
    begin: '@"'
    beginCaptures:
      '0': { name: punctuation.definition.string.begin.k }
    end: '"(?=[^"])'
    endCaptures:
      '0': { name: punctuation.definition.string.end.k }
    patterns:
    - include: '#verbatim-string-character-escape'

  verbatim-string-character-escape:
    name: constant.character.escape.k
    match: '""'

  tuple-literal:
    begin: (\()(?=.*[:,])
    beginCaptures:
      '1': { name: punctuation.parenthesis.open.k }
    end: \)
    endCaptures:
      '0': { name: punctuation.parenthesis.close.k }
    patterns:
    - include: '#comment'
    - include: '#tuple-literal-element'
    - include: '#punctuation-comma'

  tuple-literal-element:
    begin: |-
      (?x)
      (?:(@?[_[:alpha:]][_[:alnum:]]*)\s*(:)\s*)?
      (?![,)])
    beginCaptures:
      '0': { name: entity.name.variable.tuple-element.k }
      '1': { name: punctuation.separator.colon.k }
    end: (?=[,)])
    patterns:
    - include: '#expression'

  expression-operators:
    patterns:
    - name: keyword.operator.assignment.compound.k
      match: \*=|/=|%=|\+=|-=|\?\?=
    - name: keyword.operator.assignment.compound.bitwise.k
      match: \&=|\^=|<<=|>>=|\|=
    - name: keyword.operator.bitwise.shift.k
      match: <<|>>
    - name: keyword.operator.comparison.k
      match: ==|!=
    - name: keyword.operator.relational.k
      match: <=|>=|<|>
    - name: keyword.operator.logical.k
      match: \!|&&|\|\|
    - name: keyword.operator.bitwise.k
      match: \&|~|\^|\|
    - name: keyword.operator.assignment.k
      match: \=
    - name: keyword.operator.decrement.k
      match: --
    - name: keyword.operator.increment.k
      match: \+\+
    - name: keyword.operator.arithmetic.k
      match: '%|\*|/|-|\+'
    - name: keyword.operator.null-coalescing.k
      match: \?\?

  switch-literal:
    # <<: *null-literal
    name: constant.language.null.k
    match: (?<!\.)\bnull\b
    beginCaptures:
      '1': { name: constant.language.null.k }
    patterns:
      - include: '#comment'
      - include: '#punctuation-comma'
      - include: '#expression-body'

  conditional-operator:
    # Only match ? if:
    # 1. There isn't a preceding or trailing ? (null-coalescing operator)
    # 2. There isn't a trailing . or [ (null-conditional operator)
    begin: \?(?!\s*[?.\[]|\s*$)
    beginCaptures:
      '0': { name: keyword.operator.conditional.question-mark.k }
    end: ':'
    endCaptures:
      '0': { name: keyword.operator.conditional.colon.k }
    patterns:
    - include: '#expression'

  await-expression:
    name: keyword.other.await.k
    match: (?!\.)\b(await)\b

  parenthesized-expression:
    begin: \(
    beginCaptures:
      '0': { name: punctuation.parenthesis.open.k }
    end: \)
    endCaptures:
      '0': { name: punctuation.parenthesis.close.k }
    patterns:
    - include: '#expression'

  initializer-expression:
    begin: \{
    beginCaptures:
      '0': { name: punctuation.curlybrace.open.k }
    end: \}
    endCaptures:
      '0': { name: punctuation.curlybrace.close.k }
    patterns:
    - include: '#expression'
    - include: '#punctuation-comma'

  identifier:
    name: variable.other.readwrite.k
    match: '@?[_[:alpha:]][_[:alnum:]]*'

  cast-expression:
    match: |-
      (?x)
      (\()\s*
      (?<type_name>
        (?:
          (?:
            (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
            (?<name_and_type_args> # identifier + type arguments (if any)
              \g<identifier>\s*
              (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
            )
            (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
            (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
          )
          (?:\s*\?\s*)? # nullable suffix?
          (?:\s* # array suffix?
            \[
              (?:\s*,\s*)* # commata for multi-dimensional arrays
            \]
            \s*
            (?:\?)? # arrays can be nullable reference types
            \s*
          )*
        )
      )\s*
      (\))(?=\s*-*!*@?[_[:alnum:]\(])
    captures:
      '1': { name: punctuation.parenthesis.open.k }
      '2':
        patterns:
        - include: '#type'
      # '3': ?<identifier> is a sub-expression. Its final value is not considered.
      # '4': ?<name_and_type_args> is a sub-expression. Its final value is not considered.
      # '5': ?<type_args> is a sub-expression. Its final value is not considered.
      # '6': ?<tuple> is a sub-expression. Its final value is not considered.
      '7': { name: punctuation.parenthesis.close.k }

  as-expression:
    match: |-
      (?x)
      (?<!\.)\b(as)\b\s*
      (?<type_name>
        (?:
          (?:
            (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
            (?<name_and_type_args> # identifier + type arguments (if any)
              \g<identifier>\s*
              (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
            )
            (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
            (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
          )
          (?:\s*\?\s*)? # nullable suffix?
          (?:\s* # array suffix?
            \[
              (?:\s*,\s*)* # commata for multi-dimensional arrays
            \]
            \s*
            (?:\?)? # arrays can be nullable reference types
            \s*
          )*
        )
      )?
    captures:
      '1': { name: keyword.other.as.k }
      '2':
        patterns:
        - include: '#type'

  is-expression:
    match: |-
      (?x)
      (?<!\.)\b(is)\b\s*
      (?<type_name>
        (?:
          (?:
            (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
            (?<name_and_type_args> # identifier + type arguments (if any)
              \g<identifier>\s*
              (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
            )
            (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
            (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
          )
          (?:\s*\?\s*)? # nullable suffix?
          (?:\s* # array suffix?
            \[
              (?:\s*,\s*)* # commata for multi-dimensional arrays
            \]
            \s*
            (?:\?)? # arrays can be nullable reference types
            \s*
          )*
        )
      )?
    captures:
      '1': { name: keyword.other.is.k }
      '2':
        patterns:
        - include: '#type'

  this-or-base-expression:
    match: \b(?:(base)|(this))\b
    captures:
      '1': { name: keyword.other.base.k }
      '2': { name: keyword.other.this.k }

  invocation-expression:
    begin: |-
      (?x)
      (?:(\?)\s*)?                                     # preceding null-conditional operator?
      (?:(\.)\s*)?                                     # preceding dot?
      (@?[_[:alpha:]][_[:alnum:]]*)\s*                   # method name
      (?<type_args>\s*<([^<>]|\g<type_args>)+>\s*)?\s* # type arguments
      (?=\()                                           # open paren of argument list
    beginCaptures:
      '1': { name: keyword.operator.null-conditional.k }
      '2': { name: punctuation.accessor.k }
      '3': { name: entity.name.function.k }
      '4':
        patterns:
        - include: '#type-arguments'
    end: (?<=\))
    patterns:
    - include: '#argument-list'

  element-access-expression:
    begin: |-
      (?x)
      (?:(\?)\s*)?                        # preceding null-conditional operator?
      (?:(\.)\s*)?                        # preceding dot?
      (?:(@?[_[:alpha:]][_[:alnum:]]*)\s*)? # property name
      (?:(\?)\s*)?                        # null-conditional operator?
      (?=\[)                              # open bracket of argument list
    beginCaptures:
      '1': { name: keyword.operator.null-conditional.k }
      '2': { name: punctuation.accessor.k }
      '3': { name: variable.other.object.property.k }
      '4': { name: keyword.operator.null-conditional.k }
    end: (?<=\])(?!\s*\[)
    patterns:
    - include: '#bracketed-argument-list'

  member-access-expression:
    patterns:
      # An identifier with no type parameters and a dot to the left should
      # be treated as a property, so long as it isn't followed by a ( or [.
    - match: |-
        (?x)
        (?:(\?)\s*)?                   # preceding null-conditional operator?
        (\.)\s*                        # preceding dot
        (@?[_[:alpha:]][_[:alnum:]]*)\s* # property name
        (?![_[:alnum:]]|\(|(\?)?\[|<)  # next character is not alpha-numeric, nor a (, [, or <. Also, test for ?[
      captures:
        '1': { name: keyword.operator.null-conditional.k }
        '2': { name: punctuation.accessor.k }
        '3': { name: variable.other.object.property.k }
      # An identifier with type parameters should be treated as an object,
      # regardless of whether there is a dot to the left.
    - match: |-
        (?x)
        (\.)?\s*
        (@?[_[:alpha:]][_[:alnum:]]*)
        (?<type_params>\s*<([^<>]|\g<type_params>)+>\s*)
        (?=
          (\s*\?)?
          \s*\.\s*@?[_[:alpha:]][_[:alnum:]]*
        )
      captures:
        '1': { name: punctuation.accessor.k }
        '2': { name: variable.other.object.k }
        '3':
          patterns:
          - include: '#type-arguments'
      # An identifier with no type parameters (and no dot to the left per the
      # matches above) should be treated as an object.
    - match: |-
        (?x)
        (@?[_[:alpha:]][_[:alnum:]]*)
        (?=
          (\s*\?)?
          \s*\.\s*@?[_[:alpha:]][_[:alnum:]]*
        )
      captures:
        '1': { name: variable.other.object.k }
  object-creation-expression:
    patterns:
    - include: '#object-creation-expression-with-parameters'
    - include: '#object-creation-expression-with-no-parameters'

  object-creation-expression-with-parameters:
    begin: |-
      (?x)
      (new)\s+
      (?<type_name>
        (?:
          (?:
            (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
            (?<name_and_type_args> # identifier + type arguments (if any)
              \g<identifier>\s*
              (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
            )
            (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
            (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
          )
          (?:\s*\?\s*)? # nullable suffix?
          (?:\s* # array suffix?
            \[
              (?:\s*,\s*)* # commata for multi-dimensional arrays
            \]
            \s*
            (?:\?)? # arrays can be nullable reference types
            \s*
          )*
        )
      )\s*
      (?=\()
    beginCaptures:
      '1': { name: keyword.other.new.k }
      '2':
        patterns:
        - include: '#type'
    end: (?<=\))
    patterns:
    - include: '#argument-list'

  object-creation-expression-with-no-parameters:
    match: |-
      (?x)
      (new)\s+
      (?<type_name>
        (?:
          (?:
            (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
            (?<name_and_type_args> # identifier + type arguments (if any)
              \g<identifier>\s*
              (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
            )
            (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
            (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
          )
          (?:\s*\?\s*)? # nullable suffix?
          (?:\s* # array suffix?
            \[
              (?:\s*,\s*)* # commata for multi-dimensional arrays
            \]
            \s*
            (?:\?)? # arrays can be nullable reference types
            \s*
          )*
        )
      )\s*
      (?=\{|$)
    captures:
      '1': { name: keyword.other.new.k }
      '2':
        patterns:
        - include: '#type'

  array-creation-expression:
    begin: |-
      (?x)
      \b(new|stackalloc)\b\s*
      (?<type_name>
        (?:
          (?:
            (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
            (?<name_and_type_args> # identifier + type arguments (if any)
              \g<identifier>\s*
              (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
            )
            (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
            (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
          )
          (?:\s*\?\s*)? # nullable suffix?
          (?:\s* # array suffix?
            \[
              (?:\s*,\s*)* # commata for multi-dimensional arrays
            \]
            \s*
            (?:\?)? # arrays can be nullable reference types
            \s*
          )*
        )
      )?\s*
      (?=\[)
    beginCaptures:
      '1': { name: keyword.other.new.k }
      '2':
        patterns:
        - include: '#type'
    end: (?<=\])
    patterns:
    - include: '#bracketed-argument-list'

  anonymous-object-creation-expression:
    begin: \b(new)\b\s*(?=\{|$)
    beginCaptures:
      '1': { name: keyword.other.new.k }
    end: (?<=\})
    patterns:
    - include: '#initializer-expression'

  bracketed-parameter-list:
    begin: (?=(\[))
    beginCaptures:
      '1': { name: punctuation.squarebracket.open.k }
    end: (?=(\]))
    endCaptures:
      '1': { name: punctuation.squarebracket.close.k }
    patterns:
    # Note: We have to be careful here to skip the [. Otherwise, attributes will conflict.
    - begin: (?<=\[)
      end: (?=\])
      patterns:
      - include: '#comment'
      - include: '#attribute-section'
      - include: '#parameter'
      - include: '#punctuation-comma'
      - include: '#variable-initializer'

  parenthesized-parameter-list:
    begin: (\()
    beginCaptures:
      '0': { name: punctuation.parenthesis.open.k }
    end: (\))
    endCaptures:
      '0': { name: punctuation.parenthesis.close.k }
    patterns:
    - include: '#comment'
    - include: '#attribute-section'
    - include: '#parameter'
    - include: '#punctuation-comma'
    - include: '#variable-initializer'

  parameter:
    match: |-
      (?x)
      (?:(?:\b(ref|params|out|in|this)\b)\s+)?
      (?<type_name>
        (?:
          (?:ref\s+)?   # ref return
          (?:
            (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
            (?<name_and_type_args> # identifier + type arguments (if any)
              \g<identifier>\s*
              (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
            )
            (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
            (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
          )
          (?:\s*\?\s*)? # nullable suffix?
          (?:\s* # array suffix?
            \[
              (?:\s*,\s*)* # commata for multi-dimensional arrays
            \]
            \s*
            (?:\?)? # arrays can be nullable reference types
            \s*
          )*
        )
      )\s+
      (\g<identifier>)
    captures:
      '1': { name: storage.modifier.k }
      '2':
        patterns:
        - include: '#type'
      # '3': ?<identifier> is a sub-expression. Its final value is not considered.
      # '4': ?<name_and_type_args> is a sub-expression. Its final value is not considered.
      # '5': ?<type_args> is a sub-expression. Its final value is not considered.
      # '6': ?<tuple> is a sub-expression. Its final value is not considered.
      '7': { name: entity.name.variable.parameter.k }

  argument-list:
    begin: \(
    beginCaptures:
      '0': { name: punctuation.parenthesis.open.k }
    end: \)
    endCaptures:
      '0': { name: punctuation.parenthesis.close.k }
    patterns:
    - include: '#named-argument'
    - include: '#argument'
    - include: '#punctuation-comma'

  bracketed-argument-list:
    begin: \[
    beginCaptures:
      '0': { name: punctuation.squarebracket.open.k }
    end: \]
    endCaptures:
      '0': { name: punctuation.squarebracket.close.k }
    patterns:
    - include: '#named-argument'
    - include: '#argument'
    - include: '#punctuation-comma'

  named-argument:
    begin: (@?[_[:alpha:]][_[:alnum:]]*)\s*(:)
    beginCaptures:
      '1': { name: entity.name.variable.parameter.k }
      '2': { name: punctuation.separator.colon.k }
    end: (?=(,|\)|\]))
    patterns:
    - include: '#argument'

  argument:
    patterns:
    - name: storage.modifier.k
      match: \b(ref|out|in)\b
    - include: '#declaration-expression-local'
    - include: '#expression'

  query-expression:
    begin: |-
      (?x)
      \b(from)\b\s*
      (?<type_name>
        (?:
          (?:
            (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
            (?<name_and_type_args> # identifier + type arguments (if any)
              \g<identifier>\s*
              (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
            )
            (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
            (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
          )
          (?:\s*\?\s*)? # nullable suffix?
          (?:\s* # array suffix?
            \[
              (?:\s*,\s*)* # commata for multi-dimensional arrays
            \]
            \s*
            (?:\?)? # arrays can be nullable reference types
            \s*
          )*
        )
      )?
      \s+(\g<identifier>)\b\s*
      \b(in)\b\s*
    beginCaptures:
      '1': { name: keyword.query.from.k }
      '2':
        patterns:
        - include: '#type'
      # '3': ?<identifier> is a sub-expression. Its final value is not considered.
      # '4': ?<name_and_type_args> is a sub-expression. Its final value is not considered.
      # '5': ?<type_args> is a sub-expression. Its final value is not considered.
      # '6': ?<tuple> is a sub-expression. Its final value is not considered.
      '7': { name: entity.name.variable.range-variable.k }
      '8': { name: keyword.query.in.k }
    end: (?=;|\))
    patterns:
    - include: '#query-body'
    - include: '#expression'

  query-body:
    patterns:
    - include: '#let-clause'
    - include: '#where-clause'
    - include: '#join-clause'
    - include: '#orderby-clause'
    - include: '#select-clause'
    - include: '#group-clause'

  let-clause:
    begin: |-
      (?x)
      \b(let)\b\s*
      (@?[_[:alpha:]][_[:alnum:]]*)\b\s*
      (=)\s*
    beginCaptures:
      '1': { name: keyword.query.let.k }
      '2': { name: entity.name.variable.range-variable.k }
      '3': { name: keyword.operator.assignment.k }
    end: (?=;|\))
    patterns:
    - include: '#query-body'
    - include: '#expression'

  where-clause:
    begin: |-
      (?x)
      \b(where)\b\s*
    beginCaptures:
      '1': { name: keyword.query.where.k }
    end: (?=;|\))
    patterns:
    - include: '#query-body'
    - include: '#expression'

  join-clause:
    begin: |-
      (?x)
      \b(join)\b\s*
      (?<type_name>
        (?:
          (?:
            (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
            (?<name_and_type_args> # identifier + type arguments (if any)
              \g<identifier>\s*
              (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
            )
            (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
            (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
          )
          (?:\s*\?\s*)? # nullable suffix?
          (?:\s* # array suffix?
            \[
              (?:\s*,\s*)* # commata for multi-dimensional arrays
            \]
            \s*
            (?:\?)? # arrays can be nullable reference types
            \s*
          )*
        )
      )?
      \s+(\g<identifier>)\b\s*
      \b(in)\b\s*
    beginCaptures:
      '1': { name: keyword.query.join.k }
      '2':
        patterns:
        - include: '#type'
      # '3': ?<identifier> is a sub-expression. Its final value is not considered.
      # '4': ?<name_and_type_args> is a sub-expression. Its final value is not considered.
      # '5': ?<type_args> is a sub-expression. Its final value is not considered.
      # '6': ?<tuple> is a sub-expression. Its final value is not considered.
      '7': { name: entity.name.variable.range-variable.k }
      '8': { name: keyword.query.in.k }
    end: (?=;|\))
    patterns:
    - include: '#join-on'
    - include: '#join-equals'
    - include: '#join-into'
    - include: '#query-body'
    - include: '#expression'

  join-on:
    match: \b(on)\b\s*
    captures:
      '1': { name: keyword.query.on.k }

  join-equals:
    match: \b(equals)\b\s*
    captures:
      '1': { name: keyword.query.equals.k }

  join-into:
    match: |-
      (?x)
      \b(into)\b\s*
      (@?[_[:alpha:]][_[:alnum:]]*)\b\s*
    captures:
      '1': { name: keyword.query.into.k }
      '2': { name: entity.name.variable.range-variable.k }

  orderby-clause:
    begin: \b((orderby)|(order\s+by))\b\s*
    beginCaptures:
      '1': { name: keyword.query.orderby.k }
    end: (?=;|\))
    patterns:
    - include: '#ordering-direction'
    - include: '#query-body'
    - include: '#expression'
    - include: '#punctuation-comma'

  ordering-direction:
    match: \b(?:(ascending)|(descending)|(asc)|(desc))\b
    captures:
      '1': { name: keyword.query.ascending.k }
      '2': { name: keyword.query.descending.k }
      '3': { name: keyword.query.ascending.k }
      '4': { name: keyword.query.descending.k }

  select-clause:
    begin: \b(select)\b\s*
    beginCaptures:
      '1': { name: keyword.query.select.k }
    end: (?=;|\))
    patterns:
    - include: '#query-body'
    - include: '#expression'

  group-clause:
    begin: \b(group)\b\s*
    beginCaptures:
      '1': { name: keyword.query.group.k }
    end: (?=;|\))
    patterns:
    - include: '#group-by'
    - include: '#group-into'
    - include: '#query-body'
    - include: '#expression'

  group-by:
    match: \b(by)\b\s*
    captures:
      '1': { name: keyword.query.by.k }

  group-into:
    match: |-
      (?x)
      \b(into)\b\s*
      (@?[_[:alpha:]][_[:alnum:]]*)\b\s*
    captures:
      '1': { name: keyword.query.into.k }
      '2': { name: entity.name.variable.range-variable.k }

  anonymous-method-expression:
    patterns:
    - begin: |-
        (?x)
        (?:\b(async)\b\s*)?
        (@?[_[:alpha:]][_[:alnum:]]*)\b\s*
        (=>)
      beginCaptures:
        '1': { name: storage.modifier.k }
        '2': { name: entity.name.variable.parameter.k }
        '3': { name: keyword.operator.arrow.k }
      end: (?=\)|;|}|,)
      patterns:
      - include: '#block'
      - include: '#ref-modifier'
      - include: '#expression'
    - begin: |-
        (?x)
        (?:\b(async)\b\s*)?
        (\(.*?\))\s*
        (=>)
      beginCaptures:
        '1': { name: storage.modifier.k }
        '2':
          patterns:
          - include: '#lambda-parameter-list'
        '3': { name: keyword.operator.arrow.k }
      end: (?=\)|;|}|,)
      patterns:
      - include: '#block'
      - include: '#ref-modifier'
      - include: '#expression'
    - begin: |-
        (?x)
        (?:\b(async)\b\s*)?
        (?:\b(delegate)\b\s*)
      beginCaptures:
        '1': { name: storage.modifier.k }
        '2': { name: keyword.other.delegate.k }
      end: (?=\)|;|}|,)
      patterns:
      - include: '#parenthesized-parameter-list'
      - include: '#block'
      - include: '#expression'
  lambda-parameter-list:
    begin: \(
    beginCaptures:
      '0': { name: punctuation.parenthesis.open.k }
    end: \)
    endCaptures:
      '0': { name: punctuation.parenthesis.close.k }
    patterns:
    - include: '#comment'
    - include: '#attribute-section'
    - include: '#lambda-parameter'
    - include: '#punctuation-comma'

  lambda-parameter:
    match: |-
      (?x)
      (?:\b(ref|out|in)\b)?\s*
      (?:(?<type_name>
        (?:
          (?:
            (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
            (?<name_and_type_args> # identifier + type arguments (if any)
              \g<identifier>\s*
              (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
            )
            (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
            (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
          )
          (?:\s*\?\s*)? # nullable suffix?
          (?:\s* # array suffix?
            \[
              (?:\s*,\s*)* # commata for multi-dimensional arrays
            \]
            \s*
            (?:\?)? # arrays can be nullable reference types
            \s*
          )*
        )
      )\s+)?
      (\g<identifier>)\b\s*
      (?=[,)])
    captures:
      '1': { name: storage.modifier.k }
      '2':
        patterns:
        - include: '#type'
      # '3': ?<identifier> is a sub-expression. Its final value is not considered.
      # '4': ?<name_and_type_args> is a sub-expression. Its final value is not considered.
      # '5': ?<type_args> is a sub-expression. Its final value is not considered.
      # '6': ?<tuple> is a sub-expression. Its final value is not considered.
      '7': { name: entity.name.variable.parameter.k }

  type:
    name: meta.type.k
    patterns:
    - include: '#comment'
    - include: '#ref-modifier'
    - include: '#readonly-modifier'
    - include: '#tuple-type'
    - include: '#type-builtin'
    - include: '#type-name'
    - include: '#type-arguments'
    - include: '#type-array-suffix'
    - include: '#type-nullable-suffix'

  ref-modifier:
    name: storage.modifier.k
    match: \b(ref)\b

  readonly-modifier:
    name: storage.modifier.k
    match: \b(readonly)\b

  tuple-type:
    begin: \(
    beginCaptures:
      '0': { name: punctuation.parenthesis.open.k }
    end: \)
    endCaptures:
      '0': { name: punctuation.parenthesis.close.k }
    patterns:
    - include: '#tuple-element'
    - include: '#punctuation-comma'

  tuple-element:
    match: |-
      (?x)
      (?<type_name>
        (?:
          (?:
            (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\s*\:\:\s*)? # alias-qualification
            (?<name_and_type_args> # identifier + type arguments (if any)
              \g<identifier>\s*
              (?<type_args>\s*<(?:[^<>]|\g<type_args>)+>\s*)?
            )
            (?:\s*\.\s*\g<name_and_type_args>)* | # Are there any more names being dotted into?
            (?<tuple>\s*\((?:[^\(\)]|\g<tuple>)+\))
          )
          (?:\s*\?\s*)? # nullable suffix?
          (?:\s* # array suffix?
            \[
              (?:\s*,\s*)* # commata for multi-dimensional arrays
            \]
            \s*
            (?:\?)? # arrays can be nullable reference types
            \s*
          )*
        )
      )
      (?:(?<tuple_name>\g<identifier>)\b)?
    captures:
      '1':
        patterns:
        - include: '#type'
      # '2': ?<identifier> is a sub-expression. Its final value is not considered.
      # '3': ?<name_and_type_args> is a sub-expression. Its final value is not considered.
      # '4': ?<type_args> is a sub-expression. Its final value is not considered.
      # '5': ?<tuple> is a sub-expression. Its final value is not considered.
      '6': { name: entity.name.variable.tuple-element.k }

  type-builtin:
    match: \b(bool|byte|char|decimal|double|float|int|long|object|sbyte|short|string|uint|ulong|ushort|void|dynamic)\b
    captures:
      '1': { name: keyword.type.k }

  type-name:
    patterns:
    - match: (@?[_[:alpha:]][_[:alnum:]]*)\s*(\:\:)
      captures:
        '1': { name: entity.name.type.alias.k }
        '2': { name: punctuation.separator.coloncolon.k }
    - match: (@?[_[:alpha:]][_[:alnum:]]*)\s*(\.)
      captures:
        '1': { name: storage.type.k }
        '2': { name: punctuation.accessor.k }
    - match: (\.)\s*(@?[_[:alpha:]][_[:alnum:]]*)
      captures:
        '1': { name: punctuation.accessor.k }
        '2': { name: storage.type.k }
    - name: storage.type.k
      match: '@?[_[:alpha:]][_[:alnum:]]*'

  type-arguments:
    begin: '<'
    beginCaptures:
      '0': { name: punctuation.definition.typeparameters.begin.k }
    end: '>'
    endCaptures:
      '0': { name: punctuation.definition.typeparameters.end.k }
    patterns:
    - include: '#comment'
    - include: '#type'
    - include: '#punctuation-comma'

  type-array-suffix:
    begin: \[
    beginCaptures:
      '0': { name: punctuation.squarebracket.open.k }
    end: \]
    endCaptures:
      '0': { name: punctuation.squarebracket.close.k }
    patterns:
    - include: '#punctuation-comma'

  type-nullable-suffix:
    match: '\?'
    captures:
      '0': { name: punctuation.separator.question-mark.k }

  operator-assignment:
    name: keyword.operator.assignment.k
    match: (?<!=|!)(=)(?!=)

  punctuation-comma:
    name: punctuation.separator.comma.k
    match: ','

  punctuation-semicolon:
    name: punctuation.terminator.statement.k
    match: ;

  punctuation-accessor:
    name: punctuation.accessor.k
    match: \.

  preprocessor:
    name: meta.preprocessor.k
    begin: ^\s*(\#)\s*
    beginCaptures:
      '1': { name: punctuation.separator.hash.k }
    end: (?<=$)
    patterns:
    - include: '#comment'
    - include: '#preprocessor-define-or-undef'
    - include: '#preprocessor-if-or-elif'
    - include: '#preprocessor-else-or-endif'
    - include: '#preprocessor-warning-or-error'
    - include: '#preprocessor-region'
    - include: '#preprocessor-endregion'
    - include: '#preprocessor-load'
    - include: '#preprocessor-r'
    - include: '#preprocessor-line'
    - include: '#preprocessor-pragma-warning'
    - include: '#preprocessor-pragma-checksum'

  preprocessor-define-or-undef:
    match: \b(?:(define)|(undef))\b\s*\b([_[:alpha:]][_[:alnum:]]*)\b
    captures:
      '1': { name: keyword.preprocessor.define.k }
      '2': { name: keyword.preprocessor.undef.k }
      '3': { name: entity.name.variable.preprocessor.symbol.k }

  preprocessor-if-or-elif:
    begin: \b(?:(if)|(elif))\b
    beginCaptures:
      '1': { name: keyword.preprocessor.if.k }
      '2': { name: keyword.preprocessor.elif.k }
    end: (?=$)
    patterns:
    - include: '#comment'
    - include: '#preprocessor-expression'

  preprocessor-else-or-endif:
    match: \b(?:(else)|(endif))\b
    captures:
      '1': { name: keyword.preprocessor.else.k }
      '2': { name: keyword.preprocessor.endif.k }

  preprocessor-warning-or-error:
    match: \b(?:(warning)|(error))\b\s*(.*)(?=$)
    captures:
      '1': { name: keyword.preprocessor.warning.k }
      '2': { name: keyword.preprocessor.error.k }
      '3': { name: string.unquoted.preprocessor.message.k }

  preprocessor-load:
    begin: \b(load)\b
    beginCaptures:
      '1': { name: keyword.preprocessor.load.k }
    end: (?=$)
    patterns:
    - match: \"[^"]*\"
      captures:
        '0': { name: string.quoted.double.k }

  preprocessor-r:
    begin: \b(r)\b
    beginCaptures:
      '1': { name: keyword.preprocessor.r.k }
    end: (?=$)
    patterns:
    - match: \"[^"]*\"
      captures:
        '0': { name: string.quoted.double.k }

  preprocessor-region:
    match: \b(region)\b\s*(.*)(?=$)
    captures:
      '1': { name: keyword.preprocessor.region.k }
      '2': { name: string.unquoted.preprocessor.message.k }

  preprocessor-endregion:
    match: \b(endregion)\b
    captures:
      '1': { name: keyword.preprocessor.endregion.k }

  preprocessor-line:
    begin: \b(line)\b
    beginCaptures:
      '1': { name: keyword.preprocessor.line.k }
    end: (?=$)
    patterns:
    - match: \b(?:(default|hidden))
      captures:
        '1': { name: keyword.preprocessor.default.k }
        '2': { name: keyword.preprocessor.hidden.k }
    - match: '[0-9]+'
      captures:
        '0': { name: constant.numeric.decimal.k }
    - match: \"[^"]*\"
      captures:
        '0': { name: string.quoted.double.k }

  preprocessor-pragma-warning:
    match: \b(pragma)\b\s*\b(warning)\b\s*\b(?:(disable)|(restore))\b(\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
    captures:
      '1': { name: keyword.preprocessor.pragma.k }
      '2': { name: keyword.preprocessor.warning.k }
      '3': { name: keyword.preprocessor.disable.k }
      '4': { name: keyword.preprocessor.restore.k }
      '5':
        patterns:
        - match: '[0-9]+'
          captures:
            '0': { name: constant.numeric.decimal.k }
        - include: '#punctuation-comma'

  preprocessor-pragma-checksum:
    match: \b(pragma)\b\s*\b(checksum)\b\s*(\"[^"]*\")\s*(\"[^"]*\")\s*(\"[^"]*\")
    captures:
      '1': { name: keyword.preprocessor.pragma.k }
      '2': { name: keyword.preprocessor.checksum.k }
      '3': { name: string.quoted.double.k }
      '4': { name: string.quoted.double.k }
      '5': { name: string.quoted.double.k }

  preprocessor-expression:
    patterns:
    - begin: \(
      beginCaptures:
        '0': { name: punctuation.parenthesis.open.k }
      end: \)
      endCaptures:
        '0': { name: punctuation.parenthesis.close.k }
      patterns:
      - include: '#preprocessor-expression'
    - match: \b(?:(true)|(false)|([_[:alpha:]][_[:alnum:]]*))\b
      captures:
        '1': { name: constant.language.boolean.true.k }
        '2': { name: constant.language.boolean.false.k }
        '3': { name: entity.name.variable.preprocessor.symbol.k }
    - match: (==|!=)|(\!|&&|\|\|)
      captures:
        '1': { name: keyword.operator.comparison.k }
        '2': { name: keyword.operator.logical.k }

  comment:
    patterns:
    - name: comment.block.k
      begin: /\*
      beginCaptures:
        '0': { name: punctuation.definition.comment.k }
      end: \*/
      endCaptures:
        '0': { name: punctuation.definition.comment.k }
    - begin: (^\s+)?(?=//)
      beginCaptures:
        '1': { name: punctuation.whitespace.comment.leading.k }
      end: (?=$)
      patterns:
      - name: comment.block.documentation.k
        begin: (?<!/)///(?!/)
        beginCaptures:
          '0': { name: punctuation.definition.comment.k }
        end: (?=$)
        patterns:
        - include: '#xml-doc-comment'
      - name: comment.line.double-slash.k
        begin: (?<!/)//(?:(?!/)|(?=//))
        beginCaptures:
          '0': { name: punctuation.definition.comment.k }
        end: (?=$)

  xml-doc-comment:
    patterns:
    - include: '#xml-comment'
    - include: '#xml-character-entity'
    - include: '#xml-cdata'
    - include: '#xml-tag'

  xml-tag:
    name: meta.tag.k
    begin: |-
      (?x)
      (</?)
      (
        (?:
          ([-_[:alnum:]]+)
          (:)
        )?
        ([-_[:alnum:]]+)
      )
    beginCaptures:
      '1': { name: punctuation.definition.tag.k }
      '2': { name: entity.name.tag.k }
      '3': { name: entity.name.tag.namespace.k }
      '4': { name: punctuation.separator.colon.k }
      '5': { name: entity.name.tag.localname.k }
    end: (/?>)
    endCaptures:
      '1': { name: punctuation.definition.tag.k }
    patterns:
    - include: '#xml-attribute'

  xml-attribute:
    patterns:
    - match: |-
        (?x)
        (?:^|\s+)
        (
          (?:
            ([-_[:alnum:]]+)
            (:)
          )?
          ([-_[:alnum:]]+)
        )
        (=)
      captures:
        '1': { name: entity.other.attribute-name.k }
        '2': { name: entity.other.attribute-name.namespace.k }
        '3': { name: punctuation.separator.colon.k }
        '4': { name: entity.other.attribute-name.localname.k }
        '5': { name: punctuation.separator.equals.k }
    - include: '#xml-string'

  xml-cdata:
    name: string.unquoted.cdata.k
    begin: <!\[CDATA\[
    beginCaptures:
      '0': { name: punctuation.definition.string.begin.k }
    end: \]\]>
    endCaptures:
      '0': { name: punctuation.definition.string.end.k }

  xml-string:
    patterns:
    - name: string.quoted.single.k
      begin: \'
      beginCaptures:
        '0': { name: punctuation.definition.string.begin.k }
      end: \'
      endCaptures:
        '0': { name: punctuation.definition.string.end.k }
      patterns:
      - include: '#xml-character-entity'
    - name: string.quoted.double.k
      begin: \"
      beginCaptures:
        '0': { name: punctuation.definition.string.begin.k }
      end: \"
      endCaptures:
        '0': { name: punctuation.definition.string.end.k }
      patterns:
      - include: '#xml-character-entity'

  xml-character-entity:
    patterns:
    - name: constant.character.entity.k
      match: |-
        (?x)
        (&)
        (
          (?:[[:alpha:]:_][[:alnum:]:_.-]*)|
          (?:\#[[:digit:]]+)|
          (?:\#x[[:xdigit:]]+)
        )
        (;)
      captures:
        '1': { name: punctuation.definition.constant.k }
        '3': { name: punctuation.definition.constant.k }
    - name: invalid.illegal.bad-ampersand.k
      match: '&'

  xml-comment:
    name: comment.block.k
    begin: <!--
    beginCaptures:
      '0': { name: punctuation.definition.comment.k }
    end: -->
    endCaptures:
      '0': { name: punctuation.definition.comment.k }